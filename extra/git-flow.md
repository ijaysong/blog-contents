생활 코딩, 지옥에서 온 Git을 수강하고...

# 버전관리의 본질
## Mac에서 Git 설치유무 확인
~~~bash
// Git 설치유무 확인
git
~~~

## 저장소 만들기
~~~bash
// 원하는 위치에 디렉토리(워크스페이스)를 만들기
mkdir {저장소 이름}

// 해당 디렉토리 안으로 이동
cd {저장소 이름}

// 현재 디렉토리를 사용하겠다고 Git에 알려줌
git init 
~~~
git init 실행 후 생성되는 .git 파일은 여러 버전 정보를 담고 있음.

## git이 관리할 대상으로 파일 등록
~~~bash
// 파일을 생성
vim {파일명.확장자}

// git이 파일을 추적하도록 명령한다.
git add {파일명.확장자}

// 커밋
git commit

// 프로젝트 폴더의 상태를 확인한다.
git status

// 깃 로그를 확인
git log
~~~

## 버전만들기
버전이란 작업이 완결된 상태라 할 수 있다.  
이미 커밋이 된 파일을 수정할 때도 아래의 명령어를 수행하여 커밋을 해야한다. (staging의 개념)  
선택적으로 파일을 버전에 포함시키기 위함이다.  
~~~bash
git add {파일명.확장자}
~~~

## 변경사항 확인하기
~~~bash
// 버전 간의 차이점을 로그로 출력하고 싶을 때
git log -p

// 버전 간의 차이점을 비교할 때
git diff {버전 id}..{버전 id2}

// git add하기 전과 add한 후의 파일 내용을 비교할 때
git diff
~~~

git diff는 커밋 전에 변경한 소스 코드를 재검토 하기에 좋은 커맨드이다.

## 과거의 버전으로 돌아가기
~~~bash
git reset --hard {버전 id}
~~~
reset : 버전 id로 돌아가는 명령, 로컬에 있는 파일에 대해서만 수행해야 됨
revert : 버너 id의 커밋을 취소한 내용을 새로운 버전으로 만드는 명령

## 명령의 빈도와 메뉴얼 보는 방법
~~~bash
// commit 명령어에 대한 메뉴얼 확인한다
git commit --help

// add 명령어의 staging을 자동으로 수행하며 커밋한다
git commit -a

// 커밋 메세지를 지정하여 커밋을 수행
git commit -m "{커밋 메세지}"

// -a와 -m 옵션을 동시에 수행
// staging을 자동으로 수행하며 커밋 메세지를 지정하여 커밋한다
git commit -am "{커밋 메세지}"
~~~

# git의 원리
git 내부적으로 어떤 일이 일어나는지 살펴본다.

## git add의 원리
git은 add를 하면 index와 objects(객체)가 생성된다.
* index : 각각의 파일명과 인덱스가 적혀있다.
* objects/{인덱스} : add한 파일의 내용이 저장된다.

git은 파일을 저장할 때 파일 이름이 달라도 같은 내용을 가지면 같은 인덱스를 가진다. 
만개의 파일을 저장하기 위해 많은 데이터가 필요한데, 해당 파일들이 같은 내용이라면 같은 오브젝트를 가리키므로 git은 매우 효율적으로 중복 데이터를 저장할 수 있다.

## objects 파일명의 원리
git은 내용을 기반으로파일 이름이 정해지는 매커니즘을 가지고 있다. (내용이 같으면 파일의 이름이 같음) 
sha1 이라는 해쉬 알고리즘을 통해서 이름을 결정한다.

예를 들어, hello 를 sha1으로 변환해본다면 다음과 같다.
~~~
hello -sha1-> aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d
~~~

sha1으로 변환된 이름의 첫번째 두자리(aa)는 디렉토리로 생성되며, 나머지는 파일 이름으로 지정된다.

~~~
objects/aa/f4c61ddcc5e8a2dabede0f3b482cd9aea9434d
~~~

## commit의 원리
~~~bash
git commit
~~~

커밋도 내부적으로는 objects 파일 안에 저장된다.
tree, parent, 누가 저장했는지, 내용 등이 저장된다.
blob은 파일의 내용을 담는다.
tree 구조로 이전에 커밋한 내용과 새롭게 커밋한 내용들이 담긴다.

## status의 원리
~~~bash
git status
~~~
objects 파일 안의 tree와 인덱스 파일이 일치한다면, git status를 실행했을 때 커밋할 사항이 없다고 알려준다.
스테이징 되었고 커밋할 파일에 대해선, index에서 가리키고 있는 파일과 objects 파일이 연결되었으므로 index에 add 되어 커밋할 파일이 있음을 파악한다.
인덱스 파일에 등록된 파일이 local repository에 등록된다. = working directory의 파일을 git add 하여 staging area에 올라간다. (용어가 다양) 

# git의 혁신 - branch

## branch 만들기
어떤 기능을 추가할 때 branch를 생성하여 관리한다.

~~~bash
// 브랜치의 목록을 볼 때
git branch

// 브랜치를 생성할 때 
git branch {새로운 브랜치 이름}

// 브랜치를 삭제할 때
git branch -d

// 병합하지 않은 브랜치를 강제 삭제할 때 
git branch -D

// 브랜치를 전환(체크아웃)할 때
git checkout {전환하려는 브랜치 이름}

// 브랜치를 생성하고 전환까지 할 때 
git checkout -b {생성하고 전환할 브랜치 이름}
~~~

## branch 정보확인
~~~bash
// 브랜치 간에 비교할 
// 어떤 파일이 포함되어 있고 아닌지 보여줌
git log {비교할 브랜치 명 1}..{비교할 브랜치 명 2}

// 브랜치 간의 코드를 비교 할 때 
git diff {비교할 브랜치 명 1}..{비교할 브랜치 명 2}

// 로그에 모든 브랜치를 표시하고, 그래프로 표현하고, 브랜치 명을 표시하고, 한줄로 표시할 때 
git log --branches --graph --decorate --oneline 
~~~

## branch 병합 (merge)
~~~bash
// A 브랜치로 B 브랜치를 병합할 때 (A ← B)
// 먼저 A 브랜치로 체크아웃 한다.
git checkout A
// B 브랜치를 병합한다
git merge B
~~~
위와 같은 경우에는 A를 부모로 하여 B 브랜치가 합쳐진다.

## branch 수련
### fast-forward
A 브랜치로 B 브랜치를 병합한다고 해보자.(A ← B)

`fast-forward`는 영어로 빨리 감기이다.
git에서 fast-forward는 다음과 같은 상황을 뜻한다.
A 브랜치보다 B 브랜치가 작업을 추가로 수행했을 때, 추가로 수행한 내용에 맞춰서 A 브랜치를 빨리감아 B브랜치와 병합한다.
커밋을 생성하지 않는다는 특징이 있다.

### recursive strategy
B 브랜치를 머지한 A 브랜치로 C 브랜치를 병합한다고 해보자. (A <- C)

`recursive strategy` 는 직역하자면 재귀적인 전략을 뜻한다.
A 브랜치와 C 브랜치는 공통의 작업을 수행하다가 두 갈래로 나뉘었다.
마지막으로 수행한 공통 작업을 Common Ancestor라고 한다.
Common Ancestor 포인트에서 A 브랜치와 C 브랜치는 각각 추가로 더 작업을 수행하였다.
이 두 브랜치가 합쳐지면서 하나의 커밋을 생성한다.
이를 merge commit이라 한다.
(머지 시, 커밋이 수행되는 점이 fast-forward와 다른 점이다.)

## branch 병합 시 충돌해결
같은 파일 내에서 다른 line을 수정했다고 했을 때, merge를 하면 해당 내용이 합쳐진 상태로 병합된다.
하지만 같은 파일 내에서 같은 위치의 내용을 수정했을 때 문제가 된다. (충돌 발생)

~~~bash
git status
~~~
git의 상태를 파악하여 충돌이 일어난 파일을 찾을 수 있다.

~~~bash
function b() {
} 
<<<<<<< HEAD
function a(master) {
=======
function a(exp) {
>>>>>>> exp
}
function c() {
}
~~~
충돌이 발생한 파일을 수정하면 된다.
'<<<<<<< HEAD' 부터 '=======' 사이의 구간이 현재 체크 아웃된 파일의 내용이고 '=======' 부터 '>>>>>>> exp' 사이의 구간이 병합하려는 대상인 exp 브랜치의 코드 내용이다.
두개의 코드를 병합하고 특수기호들을 제거하면 된다.
작업이 끝나면 파일을 저장한다.

~~~bash
git add {충돌된 파일 이름}
~~~
충돌 작업이 끝났다는 것을 깃에게 알려준다.

~~~bash
git commit
~~~
커밋을 하면 병합이 수행된다.

## stash
stash는 감추다, 숨겨주다 라는 뜻을 가지고 있다.
stash란 파일의 변경 내용을 일시적으로 기록해두는 영역이다.
stash를 사용하여 작업 트리와 인덱스 내에서 아직 커밋하지 않는 변경을 일시적으로 저장해 둘 수 있다.
stash에 저장된 변경 내용은 나중에 다시 불러와 원래 브랜치나 다른 브랜치에 커밋할 수 있다.

ex) 이전 브랜치에서 커밋하지 않는 변경 내용을 커밋하거나, stash를 이용해 일시적으로 변경 내용을 다른 곳에 저장하여 충돌을 피하게 할때 사용 됨.
다른 브랜치로 checkout을 해야 하는데 아직 현재 브랜치에서 작업이 끝나지 않은 경우는 커밋을 하기가 애매하다.
이런 경우 stash를 이용하면 작업중이던 파일을 임시로 저장해두고 현재 브랜치의 상태를 마지막 커밋의 상태로 초기화 할 수 있다. 
그 후에 다른 브랜치로 이동하고 작업을 끝낸 후에 작업 중이던 브랜치로 복귀한 후에 이전에 작업하던 내용을 복원할 수 있다. 

~~~bash
// staging에 올라간 파일을 stash한다.
git stash

// stash 이력을 출력한다. (최근에 stash한 파일이 위에 올라간다.)
git stash list

// stash에 올라가 있는 파일을 불러온다. (list의 윗쪽부터 하나씩)
git stash apply

// stash에 올라가 있는 파일을 삭제한다. (list의 윗쪽부터 하나씩)
git stash drop

// stash에 올라가 있는 파일을 불러오며, list에서 삭제한다.
git stash apply; git stash drop;
// 다음과 같이 쓸 수도 있다.
git stash pop
~~~

## SourceTree에 표시되는 커밋 위치에 대해서

- origin/master : 원격 저장소 'origin' 브랜치인 'master'의 위치를 나타내고 있다,
- origin/HEAD : 원격 저장소 'origin'을 복제해 올 때 다운로드 되는 커밋의 위치를 나타내고 있습니다. 일반적으로 'origin/master'와 동일한 위치를 가리킵니다.
- master : 로컬 저장소 브랜치인 'master'의 위치를 나타내고 있습니다.

## branch의 종류

### 메인 브랜치 (Main branch)

'master' 브랜치와 'develop' 브랜치, 이 두 종류의 브랜치를 보통 메인 브랜치로 사용한다.

- master : 'master' 브랜치에서는 배포 가능한 상태만을 관리한다. 커밋할 때에는 태그를 사용하여 배포 번호를 기록한다.
- develop : 'develop' 브랜치는 앞서 설명한 통합 브랜치의 역할을 하며, 평소에는 이 브랜치를 기반으로 개발을 진행한다.

### 피처 브랜치 (Feature branch) 또는 토픽 브랜치 (Topic branch)

피처 브랜치는 토픽 브랜치의 역할을 담당한다.
새로운 기능 개발 및 버그 수정이 필요할 때에 'develop' 브랜치로부터 분기한다.
피처 브랜치에서의 작업은 기본적으로 공유할 필요가 없기 때문에 원격으로는 관리하지 않는다.
개발이 완료되면 'develop' 브랜치로 병합하여 다른 사람들과 공유한다.

### 릴리스 브랜치 (Release branch)

릴리즈 브랜치에서는 버그를 수정하거나 새로운 기능을 포함한 상태로 모든 기능이 정상적으로 동작하는지 확인한다.
릴리즈 브랜치의 이름은 관례적으로 브랜치 이름 앞에 'release-'를 붙인다.
이때, 다음 번 릴리즈를 위한 개발 작업은 'develop' 브랜치에서 계속 진행해 가면 된다.

릴리즈 브랜치에서는 릴리즈를 위한 최종적인 버그 수정 등의 개발을 수행한다.
모든 준비를 마치고 배포 가능한 사애가 되면 'master' 브랜치로 병합시키고, 병합한 커밋에 릴리즈 번호 태그를 추가한다.

릴리즈 브랜치에서 기능을 점검하며 발견한 버그 수정 사항은 'develop' 브랜치에도 적용해 주어야 한다.
그러므로 배포 완료 후 'develop' 브랜치에 대해서도 병합 작업을 수행한다.

### 핫픽스 브랜치 (Hotfix branch)

배포한 버전에 긴급하게 수정을 해야 할 필요가 있을 경우, 'master' 브랜치에서 분기하는 브랜치이다.
관례적으로 브랜치 이름 앞에 'hotfix-'를 붙인다.

ex)
'develop' 브랜치에서 개발을 한창 진행하고 있는 도중에 이전에 배포한 소스코드에 아주 큰 버그가 발견 된 경우!
문제가 되는 부분을 빠르게 수정해서 안정적으로 다시 배포해야 한다.
'develop' 브랜치에서 문제가 되는 부분을 수정하여 배포 가능한 버전을 만들기에는 시간도 많이 소요되고 안정성을 보장하기도 어렵다.
그렇기 때문에 바로 배포가 가능한 'master' 브랜치에서 직접 브랜치를 만들어 필요한 부분 만을 수정한 후 다시 'master' 브랜치에 병합하여 이를 배포한다.

이때 만든 핫픽스 브랜치에서의 변경 사항은 'develop' 브랜치에도 병합하여 문제가 되는 부분을 처리해 주어야 한다.

# git의 원리

## branch의 원리 
깃은 head라는 파일을 가지고 있다.
head 파일은 master 파일을 가리키며, master 파일은 최신의 커밋 파일을 가리킨다.
그렇기 때문에 git log를 입력했을 때 내용이 출력될 수 있는 것이다.
~~~
./git/refs/heads/master
~~~

브랜치(exp)를 생성하면 다음과 같이 파일이 생성된다.
~~~
.git/refs/heads/exp
~~~

## reset과 checkout의 원리
reset이란 지정한 커밋 id의 상태로 돌아가기 위한 git 커맨드이며,
해당 브랜치가 가리키고 있는 최신 로그 파일을 커밋 id 상태로 바꾸는 것을 의미한다.
~~~
git reset --hard {커밋 id}
~~~

ORIG_HEAD라는 파일은 기존에 수행한 최신 커밋 id를 가지고 있다. 
그러므로 방금 실행한 reset을 취소하고 원래 커밋으로 돌아가고 싶을 때 커밋 id 대신 ORIG_HEAD를 지정할 수 있다.
~~~
git reset --hard ORIG_HEAD
~~~

