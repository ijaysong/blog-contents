**1.토큰 기반 인증이란?**
- **토큰**을 이용해 사용자 인증작업을 처리하는 것
> - 유저가 회원 인증을 하게 될 때 **토큰**을 발급해줌으로서 유저가 자기 자신임을 인증 할 수 있게 한다.
> - 발급이 된 토큰은, 토큰의 유효기간 및 정보를 담고 있으며, 해싱 알고리즘을 통해 인증이 되어있어서 서버에서 검증을 통하여 처음 서버가 발급해주었던 정보가 변조되지 않았음을 보장 해 줄 수 있다.

-**stateless**하다.
-무상태라는 뜻이다. 서버 측에서 더 이상 유저의 인증정보를 기억하지 않고 토큰을 통해 이용자를 인증한다는 뜻이다.

> - 이 개념만으로 서버 기반 인증 방식의 많은 문제점이 해소 된다.

> > - 서버 메모리 과부하 해소
> > - 서버 확장 용이 (세션이 존재하지 않으니 유저들이 로그인 되어 있는지 신경쓰지 않으면서 scale out 가능)

---
**2.종류**
토큰 기반 방식에는 Claim(권한) 기반 토큰과 랜덤 값 기반 토큰이 있다.

||Claim 기반 토큰|랜덤 값 기반 토큰|
|----|-------------|------------------|
| 토큰값 | 공개되어도 되는 유저 정보(Claim)를 담은 토큰 ex) JWT | 랜덤한 스트링이 들어있는 토큰 ex) OAuth에 의해서 발급되는 Access token |
| 특징 | 토큰을 저장할 필요가 없다. | 토큰을 저장해야 한다. |
|  | 토큰 자체에 유저의 자원이 들어있다. | (서버) 토큰이 유효한 것인지 확인하기 위해서 저장해야 한다. |
|  | 암호화된 토큰 정보를 이용해 유효한지 아닌지 확인 할 수 있다. | (클라이언트) 토큰을 통해 유저를 식별하고자 한다면 서버에 별도로 API 호출을 보내어 유저 자원을 가져와야 한다. |

---

**3.구현방식**
토큰 기반 시스템의 구현 방식은 시스템마다 크고 작은 차이가 있겠지만, 대략적으로 다음과 같다.
(현재 spice도 이와 같은 구조로 이루어져 있다.)
![](jwt.png)

클라이언트 측에서 전달받은 토큰을 저장해두고, 서버에 요청 할때마다 해당 토큰을 HTTP 요청 헤더에 토큰 값을 포함시켜서 함께 서버에 전달한다.  

~~~ text
Authorization : Bearer <토큰>
~~~

---

**4.특징**
1.무상태(Stateless)이며 확장성(Scalability)
> - 서버는 클라이언트에 대한 정보를 저장할 필요가 없다. (토큰 해독이 되는지만 판단)
> - 그렇기에 서버를 확장하기에 매우 적합한 환경을 제공한다.  
>
> > - 만약에 세션을 서버측에서 저장하고 있고, 많은 트래픽을 감당하기 위해 여러 프로세스를 돌리거나 로드 밸런싱을 했다면, 세션의 정보가 분산된 프로세스간에 동기화가 되야하므로, 과정이 매우 복잡해진다.

2.보안성
> - 클라이언트가 서버에 요청을 보낼 때 더 이상 쿠키를 전달하지 않기 때문에 쿠키를 사용함으로써 발생하는 취약점이 사라진다. ex) XSS, CSRF

3.확장성(Extensibility)
> - 로그인 정보가 사용되는 분야가 확장된다.
> - 플랫폼간 권한을 공유할 수 있다. ex) OAuth 기능 : Facebook, LinkedIn, GitHub, Google 계정으로 로그인 할 수 있다.

4.여러 플랫폼 및 도메인 대응
> - 어떤 디바이스, 어떤 도메인에서도 토큰만 유효하다면 요청이 정상적으로 처리된다.

---

**5.문제점**
1.Stateless한 토큰의 특성 때문에 통제할 수 없다.
> - 토큰 정보가 탈취되었어도 무효화 할 수 없어 보안에 취약하다.
> - 강제로 만료 시킬 수 없다.
> - 토큰이 공격자(해커)에게 탈취되었다고 가정하면, 공격자는 토큰이 만료될 때까지 서버에 요청 할 수 있다.
> - 토큰의 주기를 너무 짧게 하면, 수시로 로그인을 다시 하게 되어 사용자가 불편해지고, 사용자의 편의를 위해 만료 주기를 길게하면 토큰이 탈취 당했을 때 피해가 커지게 된다.


=> 해결방안 : **로그인 시 access 토큰 1개, refresh 토큰 1개를 발급한다.**


- Access Token
> - 보호된 정보들에 접근할 수 있는 권한부여에 사용한다.
> - 탈취자가 access 토큰을 가로챈 경우, 마치 본인인 마냥 서버에 여러가지 요청을 보낼 수 있을 것이다.
> - 그래서 access 토큰은 비교적 짧은 유효기간을 줘서 탈취되더라도 오랫동안 사용할 수 없도록 한다.

- Refresh Token
> - access 토큰을 발급을 위한 열쇠가 된다.
> - access 토큰의 유효기간이 만료되면 refresh 토큰을 사용해서 새로운 access 토큰을 발급받아서 다시 로그인할 필요가 없게 된다.

- access 토큰이 탈취 당하더라도, refresh 토큰을 탈취하지 못하면 공격할 수 있는 시간은 얼마 되지 않는다.
- access 토큰은 api 요청 시마다 http 통신을 통해 노출되는 반면에 refresh 토큰은 access 토큰이 만료 됐을 경우에만 네트워크 통신을 통해 서버로 보내기 때문에 탈취될 위험이 현저히 적다.
- refresh 토큰도 탈취 당하면 똑같이 보안상 취약점이 생긴다.

2.토큰 저장 위치 문제
> a. Web Storage (Session Storage + Local Storage)
> > - 구현이 쉽고 하나의 도메인에 제한되어 있지 않다는 장점이 있지만, XSS 해킹 공격을 통하여 해커의 악성 스크립트에 노출이 되는 경우 매우 쉽게 토큰이 탈취될 수 있다.

> > - XSS (Cross Site Scripting)
> > > - 공격자가 악의적인 스크립트를 심어두었다가 피해자가 이를 실행시키면 피해자의 웹 브라우저에서 공격을 실행하는 것

=> 해결방안 : **사용자의 모든 입력값에 스크립트가 포함되었는지 입출력시 validation을 걸어 검증하고 무효화시킨다.**

> b. Cookie
> > - 토큰을 전달하는 전송 수단으로 활용한다.
> > - 쿠키 설정 시 httpOnly 값을 활성화 해주면 브라우저 상에서 자바스크립트로 토큰 값에 접근하는 것이 불가능해지므로 XSS 공격 방어가 가능해진다.
> > - XSS 공격은 방어가 되지만 CSRF 공격에 취약하다.

> > - CSRF (Cross Site Request Forgery)
> > > - 정상적인 request를 가로채 피해자인 척 하고 백엔드 서버에 변조된 request를 보내 악의적인 동작을 수행하는 공격을 의미한다. ex) 피해자 개인정보 열람 및 수정, 광고성 글 페이스북에 작성 등등...
> > > - HTTP 요청 Referer 체크, CSRF 토큰 사용 등을 통해 공격을 방어할 수 있다.

> > - Referer 체크
> > > - Request의 referer를 확인하여 domain이 일치하는지 검증하는 방법이다. ex) *.facebook.com

> > - CSRF 토큰 사용
> > > - 사용자의 세션에 임의의 난수 값을 지정하고, 사용자의 요청 마다 난수 값을 포함시켜 전송한다.
> > > - 이후 백엔드에서 요청을 받을 때마다 세션에 저장된 토큰 값과 요청 파라미터에 전달되는 토큰 값이 일치하는지 검증하는 방법이다.


=> 해결방안 : **httpOnly + secure 옵션 HTTPS로 통신하고, HTTP 요청 Referer 체크, CSRF 토큰 사용 등을 통해 공격을 방어한다.**


---

**6.결론**
현재 spice는 로컬 스토리지에 access 토큰 1개를 저장하고 있다.
프론트 인터셉터에서 로컬 스토리지에 저장되어 있는 토큰을 가져와 request 헤더에 셋팅, 서버 인터셉터에서 request 헤더에 담겨있는 토큰 확인을 통해 사용자 인증을 하고 있다.
로컬 스토리지에 토큰을 저장하면 쉽게 관리할 수 있어서 편하지만, XSS 공격의 가능성이 있기 때문에 보안에 취약하다고 할 수 있다.
쿠키에 저장한 값은 HttpOnly 속성을 통해 javascript를 통한 접근을 막을 수 있기 때문에 보안적인 측면을 생각한다면 웹 스토리지보다는 **쿠키**에 저장하는 것이 좋다고 할 수 있다.