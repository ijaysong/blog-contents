# Http
생활코딩 Http 강의,
인프런 '모든 개발자를 위한 HTTP 웹 기본 지식' 강의를 듣고!

## IP (인터넷 프로토콜)
인터넷 통신을 위해서 클라이언트와 서버는 각각 IP 주소를 가지고 있어야 한다.
인터넷 프로토콜은 IP 주소에 데이터를 전달하는 역할을 한다.
패킷(packet)이라는 통신 단위로 데이터를 전달한다.

### IP 패킷
IP 패킷에는 규칙이 있다.
보내고자 하는 데이터를 감싸는 바깥쪽에 출발지 IP와 도착지 IP, 기타 등등의 정보를 적어야 한다. 
패킷을 인터넷 통신망에 던지면, 노드는 패킷에 적혀있는 도착지 IP를 보고 해당 위치로 찾아간다.
서버에 도착한 뒤, 메세지를 받았다는 응답을 담은 새로운 패킷을 만들어서 되돌려준다.

### IP 프로토콜의 한계
* 비연결성
- 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송하고 이를 전혀 알지 못함.
- 대상 서버가 패킷을 받을 수 있는 상태인지 모름.
- ex) 편지를 보냈는데 해당 주소에 받을 사람이 살지 않음.

* 비신뢰성
- 패킷이 소실될 가능성이 있다. 중간에 패킷이 사라질 가능성이 있음.
- 패킷이 전송되는 중간에 특정 노드가 꺼져있거나 하면 소실 될 수 있는데 패킷이 소실되어도 이를 알지 못한다.
- ex) 광케이블을 야생동물이 끊어먹었다던지, 해저 케이블이 끊겼다던지...

- 패킷 전달 순서 문제가 발생한다. 패킷이 순서대로 안오는 경우가 있다.
- ex) 1번 패킷 : Hello, 2번 패킷 : world
- 1, 2번 패킷을 순서대로 전달해도 다른 경로로 노드를 거쳐 목적지 서버에 도착하기 때문에 
- 나의 의도와는 다르게 2번째 노드가 먼저 도착하는 경우가 있다.

프로토콜 만으로는 위와 같은 문제를 해결할 수 없다.
그래서 나온 것이 TCP/IP이다.

## TCP UDP
### 인터넷 프로토콜 스택의 4계층
- 애플리케이션 계층 : HTTP, FTP
- 전송 계층 : TCP, UDP
- 인터넷 계층 : IP
- 네트워크 인터페이스 계층

## 프로토콜 계층
| 계층 | 장치 |
|-----|-----|
| 애플리케이션 | 웹 브라우저, 네트워크 게임, 채팅 프로그램 |
| | SOCKET 라이브러리 |
| OS | TCP |
| | IP (Internet Protocol) |
| 네트워크 인터페이스 | LAN 드라이버 |
| | LAN 장비 |

ex)
프로그램이 Hello, world! 라는 메세지를 클라이언트로 전송한다고 해보자.

1. 애플리케이션에서 메세지를 생성한다.
2. SOCKET 라이브러리를 통해서 메세지를 전달한다.
3. OS의 TCP에서 메세지를 TCP 정보로 한번 감싼다. (TCP 정보 생성, 메세지 데이터 포함)
4. IP에서 IP정보로 한번 더 감싼다. (IP 패킷 생성, TCP 데이터 포함)
5. 네트워크 인터페이스에서 LAN 카드를 통해서 나갈때 이더넷 프레임으로 한번더 감싼다. ()
6. 인터넷을 통해 서버로 전달된다.

#### 패킷이란?
패킷은 패키지(package; 수화물)과 버킷(Bucket; 덩어리)의 합성어이다.
택배 박스에 데이터를 넣는 것과 같은 이미지로 생각해보자.

### IP 패킷
출발지 IP, 목적지 IP, 기타...

### TCP 세그먼트
출발지 PORT, 목적지 PORT, 전송제어, 순서, 검증 정보...
(IP 프로토콜만으로 해결이 되지 않았던 것이 TCP 세그먼트의 전송제어로 인해 해결된다.)

### TCP 특징
전송제어 프로토콜(Transmission Control Protocol)

- 연결지향: TCP 3 way handshake (가상연결)
ex)
- SYN: 접속 요청 
- ACK: 요청 수락

TCP는 세번의 과정을 거쳐서 클라이언트와 서버와의 연결을 확인한다.
1. 클라이언트가 서버에게 접속 요청을 한다. (SYN)
2. 서버는 요청을 수락하며 접속 요청을 보낸다. (SYN + ACK)
3. 클라이언트는 서버에게 요청 수락을 보낸다. (ACK)
4. 데이터 전송
단점은 시간이 오래걸리고 TCP 세그먼트의 데이터를 다 담으면 용량이 커진다.
   
- 데이터 전달 보증
클라이언트에서 서버로 데이터를 보냈을 때, 서버는 클라이언트에게 잘 받았다고 결과를 보내줌.

- 순서 보장
ex) 클라이언트가 1, 2, 3번 패킷을 순서대로 보낸다고 해보자.
서버에서 1, 3, 2번의 순서대로 패킷을 받았다.
그러면 서버는 두번째 패킷부터 잘못 왔으니까 다시 보내달라고 한다. 
(TCP에는 전송제어 정보가 포함되어 있으므로 그것을 참고로 순서를 파악하는 것!)
그러면 클라이언트는 두번째 패킷부터 다시 보낸다.

- 신뢰할 수 있는 프로토콜
- 현재는 대부분 TCP 사용

### UDP 특징
사용자 데이터그램 프로토콜(User Datagram Protocol)

- 하얀 도화지에 비유(기능이 거의 없음)
- 연결지향: TCP 3 way handshake (가상연결)
- 데이터 전달 보증 X
- 순서 보장 X
- 데이터 전달 및 순서가 보장되지 않지만, 단순하고 빠름
- IP와 거의 같지만 PORT 체크섬 정도만 추가되었다.
- 애플리케이션에서 추가 작업이 필요하다.
- HTTP3가 등장하면서 3 way handshaking을 없애보자는 흐름이 생겨나며 UDP가 각광받고 있음.

#### 포트란?
하나의 IP에서 여러 애플리케이션이 사용하기 위해

## URI

Uniform: 리소스 식별하는 통일된 방식
Resource: 자원, URI로 식별할 수 있는 모든 것(제한 없음)
Idendifier: 다른 항목과 구분하는데 필요한 정보

리소스 식별자 URI는 로케이터(locator) 또는 이름(name) 크게 두가지로 분류될 수 있다.

- URL(Resource Locator) : 리소스의 위치
- URN(Resource Name) : 리소스의 이름

### URL

Uniform Resource Locator : 리소스가 있는 위치를 지정

ex)
foo://example.com:8042/over/there?name=ferret#nose

### URN

Uniform Resource Name : 리소스에 이름을 부여
위치는 변할 수 있지만, 이름은 변하지 않는다.

ex)
urn:example:animal:ferret:nose

URN 이름만으로 실제 리소스를 찾을 수 있는 방법이 보편화 되지 않음.
(URN으로 리소스를 찾을 수 없다고 보면 됨. 거의 사용 X)
ex)
urn:isbn:8960777331 (어떤 책의 isbn URN)

=> 그렇기 때문에 URI와 URL을 같은 의미로 봐도 무방하다.

### URL 전체 문법

- scheme://[userinfo@]host[:port][/path][?query][#fragment]
- https://www.google.com:443/search?q=hello&hl=ko

* https: 프로토콜
* www.google.com : 호스트 명
* 443 : 포트번호
* /search : 패스
* q=hello&hl=ko : 쿼리 파라미터

#### 스키마 (schema)

- 스키마는 주로 프로토콜을 사용
- 프로토콜 : 어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙
 ex) http, https, ftp 등등
- http는 80 포트, https는 443 포트를 주로 사용, 포트는 생략 가능
- https는 http에 보안 추가 (HTTP Secure)

#### userinfo

- URL에 사용자 정보를 포함해서 인증할 때 사용
- 거의 사용하지 않음

#### 호스트 (host)

- 도메인 명 or IP 주소를 직접 사용 가능

#### 포트 (port)

- 포트는 생략 가능하다.
- 일반적으로 생략하며, 생략 시 http는 80, https는 443

#### 패스 (path)

- 리소스 경로이다.
- 계층적 구조로 되어 있다. (디렉토리처럼!)
 ex)
 /home/file1.jpg
 /members
 /members/100, /items/iphone12

#### 쿼리 (query)

- key=value의 형태.
- ?로 시작, &로 추가 가능
 ex)
 ?keyA=valueA&keyB=valueB
- query parameter, query string 등으로 불림.
 (숫자가 파라미터로 지정이 되어도 다 string으로 넘어가기 때문에 query string이라고 부름)
- 웹 서버에 제공하는 파라미터로 문자 형태.

#### 프레그먼트(fragment)

ex)
https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started-introducing-spring-boot

- 웹 페이지 내부에서 특정 위치로 이동하는 북마크를 이용할 때
- html 내부 북마크 등에 사용
- 서버에 전송하는 정보 아님

## 웹 브라우저 요청 흐름

ex)
https://www.google.com:443/search?q=hello&hl=ko 에 접속해본다고 하자.

1. www.google.com의 DNS 서버를 조회하여 IP 주소를 알아낸다. (HTTPS PORT는 생략)
2. 애플리케이션 계층의 웹 브라우저가 HTTP 요청 메세지 생성
  ex)

~~~
GET /search?q=hello&hl=ko HTTP/1.1
Host: www.google.com
~~~

3. SOCKET 라이브러리를 통해 전달
4. OS 계층의 TCP/IP로 데이터를 전달한다.
  TCP는 3 way handshake로 서버와 연결이 되어 있는지 확인을 한다.
  확인을 거치면 데이터에 패킷을 씌운다. (출발지, 목적지의 IP와 PORT, 전송제어, 순서)
5. 네트워크 계층을 통해서 LAN을 통해 서버로 데이터와 http 메세지, 패킷을 보낸다.
6. 서버에 요청이 잘 도착하면 HTTP 응답 메세지를 클라이언트에게 보내준다.
  ex)

~~~
HTTP/1.1 200 OK
Content-Type: text/html;charset=UTF-8
Content-Length: 3423

<html>
 <body>...</body>
</html>
~~~

## Http 소개

HTTP(HyperText Transfer Protocol)는 HyperText 링크간에 연결이 가능한 html 전송을 목적으로 만들어졌다.
처음에는 html 전송을 위해 만들어졌지만, http 메세지에 거의 모든 형태의 데이터를 담아서 전송할 수 있게 되었다.

- HTML, TEXT
- IMAGE, 음성, 영상, 파일
- JSON, XML(API)
- 거의 모든 형태의 데이터 전송 가능
- 서버간에 데이터를 주고 받을 때도 대부분 HTTP 사용

웹브라우저와 웹서버가 컨텐츠(html, 이미지, 오디오, css, javascript 파일등)을 주고 받기 위해서 사용하는 통신규칙이다.
간단히 말해서 서버와 클라이언트가 서로 주고 받는 Request와 Response를 이해할 수 있는 메세지를 말한다.

HTTP는 추상적인 개념이지만,
크롬의 Developer tools를 사용하면 네트워크 탭에서 웹 서버가 통신하는 내용을 볼 수 있다. (네트워크 로그)

서버와 클라이언트는 다음과 같은 형식으로 헤더에 정보를 담아 요청/응답한다.
브라우저는 해당 내용을 뿌려주는 역할을 한다.

### HTTP 역사

- HTTP/0.9 1991년 : GET 메서드만 지원, HTTP 헤더 X
- HTTP/1.0 1996년 : 메서드, 헤더 추가
- HTTP/1.1 1997년 : 가장 많이 사용, 우리에게 가장 중요한 버전
  - RFC2068 (1997) -> RFC2616(1999) -> RFC7230~7235(2014)
- HTTP/2 2015년 : 성능 개선
- HTTP/3 진행 중 : TCP 대신에 UDP 사용, 성능 개선

#### 기반 프로토콜

- TCP : HTTP/1.1, HTTP/2
- UDP : HTTP/3
  - 현재 HTTP/1.1 주로 사용
  - HTTP/2, HTTP/3도 점점 증가
  - TCP는 3 way handshaking 및 담고 있는 데이터의 양이 많아 처리 속도가 느린 알고리즘
  - 성능 개선의 목적으로 UDP 도입

### HTTP 특징

#### 클라이언트 서버 구조

- Request Response 구조
- 클라이언트는 서버에 요청을 보내고, 응답을 대기
- 서버가 요청에 대한 결과를 만들어서 응답

#### 무상태 프로토콜(stateless), 비연결성

- 서버가 클라이언트의 상태를 보존 X (stateless)
  문맥을 보전하지 않는 것.

ex)
stateful 과 stateless의 차이

1. stateful (상태 유지)
   고객 : 노트북 얼마인가요?
   점원 : 100만원 입니다. => 노트북 상태 유지

고객 : 2개 구매하겠습니다.
점원 : 200만원 입니다. 신용카드, 현금 중에 어떤 걸로 구매하시겠습니까? => 노트북, 2개 상태 유지

고객 : 신용카드로 구매하겠습니다.
점원 : 200만원 결제 되었습니다. => 노트북, 2개, 신용카드 상태 유지

2. stateful (상태 유지), 중간에 점원이 계속 바뀌면??
   고객 : 노트북 얼마인가요?
   점원A : 100만원 입니다.

고객 : 2개 구매하겠습니다.
점원B : 무엇을 2개 구매하시겠습니까?

고객 : 신용카드로 구매하겠습니다.
점원C : 어떤 제품을 몇개 신용카드로 구매하시겠습니까?

3. stateless (무상태)
   고객 : 노트북 얼마인가요?
   점원 : 100만원 입니다.

고객 : 노트북 2개 구매하겠습니다.
점원 : 200만원 입니다. 신용카드, 현금 중에 어떤 걸로 구매하시겠습니까?

고객 : 노트북 2개를 신용카드로 구매하겠습니다.
점원 : 200만원 결제 되었습니다.

4. stateless (무상태), 중간에 점원이 계속 바뀌면??
   고객 : 노트북 얼마인가요?
   점원 : 100만원 입니다.

고객 : 노트북 2개 구매하겠습니다.
점원 : 200만원 입니다. 신용카드, 현금 중에 어떤 걸로 구매하시겠습니까?

고객 : 노트북 2개를 신용카드로 구매하겠습니다.
점원 : 200만원 결제 되었습니다.

- 장점 : 서버 확장성 높음(scale out)
- 단점 : 클라이언트가 추가 데이터 전송

==> 차이점 정리

- stateful (상태유지)
  중간에 다른 점원으로 바뀌면 서비스에서 장애가 발생한다.
  다른 점원으로 바뀌면 context, 문맥이 바뀌기 때문에 다른 점원으로 바뀔 때 상태 정보를 다음 사람에게 미리 알려줘야 한다.
  항상 같은 서버가 유지되어야 한다.

- stateless (무상태)
  중간에 다른 점원으로 바뀌어도 된다.
  고객이 점원에게 필요한 정보를 그때그때 다 전달하기 때문에 중간에 점원이 바뀌어도 장애가 발생하지 않는다.
  갑자기 고객이 증가해도 점원을 대거 투입할 수 있다. (= 갑자기 클라이언트 요청이 증가해도 서버를 대거 투입할 수 있다.)
  => 무상태는 응답 서버를 쉽게 바꿀 수 있다! (무한한 서버 증설 가능!!)
  => scale out, 같은 기능을 하는 서버군을 여러개로 늘리는 수평 확장에 유리하다.

==> 실무 한계

- 모든 것을 무상태로 설계할 수 있는 경우도 있고, 없는 경우도 있다.
- 무상태 ex) 로그인이 필요 없는 단순한 서비스 소개 화면
- 상태유지 ex) 로그인
- 로그인한 사용자의 경우, 로그인 했다는 상태를 서버에 유지
- 일반적으로 브라우저 쿠키와 서버 세션 등을 사용해서 상태 유지
- 최대한 무상태로 개발하고, 상태 유지는 최소한만 사용
- 데이터를 너무 많이 보내는 단점이 있음.

#### 비 연결성 (connectionless)

ex) 연결을 유지하는 모델

1. 클라이언트 1에서 요청이 오면 서버는 응답을 한다.
2. 클라이언트 2에서 요청이 오면 서버는 응답을 한다. 클라이언트 1과 서버의 연결은 여전히 유지되어 있다.
3. 클라이언트 3에서 요청이 오면 서버는 응답을 한다. 클라이언트 1과 클라이언트 2, 서버의 연결은 여전히 유지되어 있다.

=> 서버는 연결을 계속 유지, 서버 자원 소모가 많다.

ex)

1. 클라이언트 1에서 요청이 오면 서버는 응답을 한다. TCP/IP 연결을 즉시 종료한다.
2. 클라이언트 2에서 요청이 오면 서버는 응답을 한다. TCP/IP 연결을 즉시 종료한다.
3. 클라이언트 3에서 요청이 오면 서버는 응답을 한다. TCP/IP 연결을 즉시 종료한다.

=> 서버는 연결 유지 X, 최소한의 자원을 유지한다.

##### 특징

- HTTP는 기본이 연결을 유지하지 않는 모델이다.
- 일반적으로 초 단위 이하의 빠른 속도로 응답
- 1시간 동안 수천 명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십 개 이하로 매우 작다.
 ex) 웹 브라우저에서 계속 연속해서 검색 버튼을 누르진 않는다.
- 서버 자원을 매우 효율적으로 사용할 수 있다.

##### 한계와 극복

- TCP/ IP 연결을 새로 맺어야 한다. 3 way handshake 시간 추가
- 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 자바스크립트, CSS, 추가 이미지 등 수 많은 자원이 함께 다운로드
- 지금은 HTTP 지속 연결 (Persistent Connections)로 문제 해결
- HTTP/2, HTTP/3에서 더 많은 최적화

##### 서버 개발자들이 어려워하는 업무! stateless!!

- 같은 시간에 딱 맞추어 발생하는 대용량 트래픽
 ex) 선착순 이벤트 (저녁 6:00 선착순 1000명 치킨 할인 이벤트) / 명절 KTX 예약 / 학과 수업 등록
- 첫 화면에 로그인 등이 필요없는 단순 표시 페이지를 두어서 유저들이 해당 페이지에서 조금 머물다가 트래픽에 접속할 수 있도록 설계하면 여러명이 한번에 몰리는 것을 막을 수 있음

### Request
* Request Headers : Client가 Server에 요청한 내용
* View Source : 요청한 내용을 자세히 볼 수 있음

### Response
* Response Headers : Server가 Client에 응답한 내용
* HTTP/1.1 : Response Header의 제일 처음에는 이렇게 적혀있다. 해당 방식으로 통신할 것을 기재한 것.
* 200 OK : Response 상태
* Content-Length : 응답 내용의 길이
* Content-Type: text/html :해당 타입의 내용을 반환하겠다는 것

## HTTP Request message

### HTTP Request Format
Request Header의 형식은 다음과 같다.
~~~
// Request Line
GET /doc/test.html HTTP/1.1
// Request Headers
Host : test01.com
Accept: image/gif, image/jpeg, */*
Accept-Language: en-us
Accept-Encoding: gzip, deflate
User-Agent: Mozilla/4.0
Content-Length: 35

// RequestMessage Body
bookId=12345&author=Hong+gildong
~~~

* Request Message Header = Request Line + Request Headers
* Request Message Header와 RequestMessage Body 사이에 한줄을 띄워 header와 body를 구분한다.

### Request Line
* GET : Request 메소드의 하나이다. GET 이외에 POST, PUT, DELETE 등이 있다.
* /doc/test.html : 웹서버에게 요청하는 정보이다.
* HTTP/1.1 : 웹 서버가 현재 사용하고 있고, 사용할 수 있는 HTTP 버전을 말한다.

### Request Header
* Host : 컴퓨터 한대 한대를 식별하는 정보이다. 접속하고자 하는 웹 서버의 주소라고 보면 된다.
* User Agent : 웹 브라우저의 다른 표현이다. 요청하는 웹 브라우저가 무엇인지를 말한다.
ex) 로봇으로 접속했다거나 하는 특정 방식으로 접속하는 것을 차단하는 용도로 사용 된다. 
* Accept-encoding : 통신하는 데이터 양이 많아 압축을 해서 전송하면, 웹 브라우저에서 압축을 풀어서 해석 할 수도 있다.
압축해서 보냄으로서 네트워크의 자원을 아낄 수 있다.
해당 브라우저는 어떠한 압축 방식을 지원한다 라는 정보를 표현하고 있다.
* If-Modified-Since : 웹 서버에 요청한 데이터를 요청 할 때마다 다운 받으면 비효율적이므로, 해당 정보를 웹 서버에 보내면
내가 해당 파일을 언제 다운 받았다는 정보를 전달하게 된다.
그러면 웹 서버는 자신이 가지고 있는 데이터와 비교해서 어떤 것이 더 최신인지 비교해서 더 최신이면 데이터를 다운 받고, 아니면 받지 않는다.
이를 통해 속도가 더 빨라질 수 있다.

## HTTP Response message

### HTTP Response Format
Response Header의 형식은 다음과 같다.
~~~
// Status Line
HTTP/1.1 200 OK
// Response Headers
Date: Sun, 08 Feb xxxx 01:11:12 GMT
Server: Apache/1.3.29 (Win32)
Last-Modified: Sat, 07 Feb xxxx
ETag: "0-23-4024c3a5"
Accept-Ranges: bytes
Content-Length: 35
Connection: close
Content-type: text/html

// Response Message Body
<h1>My Home Page</h1>
~~~

* Response Message Header = Status Line + Response Headers
* Response Message Header와 ResponseMessage Body 사이에 한줄을 띄워 header와 body를 구분한다.


### Status Line
서버가 동작을 잘했는지, 안됐는지, 안됐다면 왜 안됐는지 등을 표시한다.
{Version} {status code} {phrase}를 표시한다.
ex) HTTP/1.1 200 OK

100번대 : 정보
200번대 : 성공
300번대 : Redirection(웹 브라우저가 다른 곳으로 바로 이동하는 것)
400번대 : 클라이언트 에러
500번대 : 서버 에러

### Response Headers
* Content-Type: 웹서버가 응답할 때 해당 양식으로 반환
* Content-Length : 컨텐츠의 사이즈(byte)
* Content-Encoding : 컨텐츠의 압축을 풀려면 해당 포맷으로
* Last-Modified : 해당 컨텐츠가 언제 마지막으로 수정되었는지 표시

## HTTP Method

### API 설계

API를 짜는데 있어서 리소스를 식별(URI)하는 것이 가장 중요하다.

리소스의 의미는 무엇일까?

- 회원을 등록하고 수정하고 조회하는 것이 리소스가 아니다.
- 회원이라는 개념 자체가 바로 리소스이다.
- 등록, 수정, 조회의 행동을 제외하고 회원 리소스를 URI에 매핑한다.

URI는 리소스만 식별한다.
리소스와 해당 리소스를 대상으로 하는 행위를 분리한다.
행위는 Http 메서드로 표현한다.

- 리소스 : 회원
- 행위 : 조회, 등록, 삭제, 변경

| 기능           | 동작   | 리소스        |
| -------------- | ------ | ------------- |
| 회원 목록 조회 | GET    | /members      |
| 회원 조회      | GET    | /members/{id} |
| 회원 등록      | POST   | /members/{id} |
| 회원 수정      | PUT    | /members/{id} |
| 회원 삭제      | DELETE | /members/{id} |

### HTTP 메서드 종류

주요 메서드

- GET : 리소스 조회
- POST : 요청 데이터 처리, 주로 등록에 사용
- PUT : 리소스를 대체, 해당 리소스가 없다면 생성
- PATCH : 리소스 부분 변경
- DELETE : 리소스 삭제

기타 메서드

- HEAD : GET과 동일하지만 메시지 부분을 제외하고, 상태 줄과 헤더만 반환
- OPTIONS : 대상 리소스에 대한 통신 가능 옵션(메서드)을 설명 (주로 CORS에서 사용)
- CONNECT : 대상 자원으로 식별되는 서버에 대한 터널을 설정
- TRACE : 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행

## 관련 토픽
### HTTPS
HTTPS의 S는 Secure의 약자로, 안전한 이라는 뜻이다.
HTTP가 처음 나왔을 때는 그렇게 위험하지 않았다.
웹을 통해서 심각한 정보를 다루지 않았기 때문!

군사, 금융, 사생활을 웹을 통해서 주고 받고 있다.
오늘날과 같은 시대에 HTTP를 사용하면 누군가가 내 정보를 들여다 보고 있다고 생각해야 한다.
반면에 HTTPS는 외부에서 가로챈다고 한들, 내부 내용이 암호화 되어 있기 때문에 훔쳐볼 수 없다.

### Cache
어떠한 웹 페이지에 접속 할 때, 매회 다운 받지 않고 어딘가에 저장해두었다가 활용함으로서 웹의 성능을 높이는 기능이다. 
웹은 캐쉬가 새롭게 갱신되었더라도 이를 알아채지 못하는 단점이 있다.
cf) 다음은 강제로 캐쉬를 갱신하는 단축키이다.
- Windows : Ctrl + F5
- MacOS : Cmd + R
- Linux : F5

헤더에 cache-control, pragma 등을 지정함으로서 캐쉬와 관련해 제어할 수 있다.

### 쿠키
쿠키에 값을 설정해 놓음으로서 개인화를 가능하게 해준다.
쿠키값에 저장되어 있는 것을 서버에 전송함으로서 사용자의 상태를 유지하고, 사용자를 식별할 수 있다.
ex)
다음에 접속할 때에 자동 로그인.
로그인 하면 장바구니에 전에 내가 담아왔던 물건이 보임.

### 웹 스토리지
최근에는 쿠키보다 더 많은 정보를 저장할 수 있으면서, 보안에서도 더욱 우수한 웹 스토리지가 생겨났다.

### proxy
웹 서버와 웹 브라우저 사이에 중계서버라고 하는 프록시가 있다.
중간에 있는 서버가 캐쉬를 대신 해주거나, 보안과 관련한 기능을 대신 해주거나, 적당히 분산하여 여러 대의 서버가 기능을 담당하는 것과 같은 역할을 프록시 서버가 대신 해준다.

### Developer tools > Network
네트워크 모니터링 기능.

### Wire Shark
무료 오픈소스.
컴퓨터에서 일어나는 모든 네트워크 트래픽을 다 확인할 수 있음.
