# `선택정렬`
## `메모리가 동작하는 방법`
고깃집에 갔을 때 신발을 넣는 여러칸의 신발장처럼 컴퓨터 메모리도 엄청나게 많은 서랍을 가지고 있다. 각각의 서랍에는 주소가 있다.
메모리에 무언가를 저장해야 할 때마다 컴퓨터에게 공간을 요청한다.
그러면 컴퓨터는 무언가를 저장할 수 있는 주소를 알려준다.

만약 여러개의 원소를 저장해야 한다면, 배열과 리스트라는 두가지 방법 중 하나를 사용해야 한다.

## `배열과 연결리스트`
해야할 일 목록을 관리하는 앱을 만든다고 생각해보자.
해야할 일 목록에는 이미 3개가 등록이 되어있다.
* 넷플릭스 보기
* 블로그 컨텐츠 작성
* 깃 올리기

### `배열`
배열을 사용하면, 할 일들을 메모리에 차례대로 붙여서 저장한다.
해야할 일 목록에 하나를 더 추가하고 싶은데 다음 메모리에 다른게 저장이 되어있다고 생각해보자.
이런 경우에는 컴퓨터에게 4개의 해야할 일 목록을 차례로 붙여서 저장할 수 있는 다른 메모리 공간을 요청하게 된다.

만약 공간이 모자라서 매번 모든 원소를 메모리의 새로운 위치로 옮긴다면? 배열에 원소를 추가하는 일은 매우 느려진다.

이를 해결할 수 있는 방법은 미리 저장 위치를 많이 할당받는 것이다.
지금은 해야할 일 목록에 할 일이 3개 밖에 없어도 만일을 대비해서 컴퓨터에게 자리를 10개 요청하는 것이다.
그러면 전체 배열을 옮기지 않아도 10개까지는 할일을 추가할 수 있다.

이 방법은 좋은 방법이지만 몇가지 단점이 있다.
1. 만약에 추가할 일이 생기지 않는다면 메모리를 쓸데없이 낭비하게 된다.
2. 만약에 목록의 크기가 10개보다 커진다면? 또 자리를 옮겨야 한다.

좋은 해결책이긴 해도 완벽한 해결책은 아니다.
연결 리스트를 사용하면 원소를 추가할 때 생기는 문제를 해결할 수 있다.

### `연결 리스트`
연결리스트의 각 원소에는 다음 원소에 대한 주소가 적혀있다.
여러 가지 임의의 메모리 주소들이 하나의 목록으로 연결되어 있는 셈이다.
연결 리스트로 원소를 추가하면, 그냥 메모리의 아무것에나 원소를 넣고 그 원소의 주소를 바로 앞의 원소에 저장하면 된다.
그러므로 연결리스트를 사용하면 원소의 위치를 옮길 일이 없다.

### `원소의 주소 찾기`
배열과 연결리스트에서 마지막 원소를 보고 싶다고 해보자.
연결리스트는 마지막 원소를 보고 싶다고 해도 바로 읽을 수 없다.
왜냐하면 그 주소를 바로 알 수 없기 떄문이다.
2번 원소의 주소가 적혀있는 1번 원소의 주소로 가서, 2번 원소의 주소를 찾아낸 다음, 3번 원소의 주소가 적힌 2번 원소로 간다.
이런 식으로 마지막 원소의 위치까지 가야한다. 
모든 원소의 값을 한번에 읽어야 한다면 연결리스트가 좋지만, 특정한 원소만 알고 싶다면 연결리스트는 최악이다.

배열은 다르다. 모든 원소의 주소를 다 알고 있다.
예를 들어 배열에 5개의 원소가 있고, 주소가 00부터 시작한다면 5번째 원소의 주소는 어떻게 될까?
답은 04이다. 
배열은 배열 안의 어떤 원소든 바로 찾을 수 있기 떄문에 원소의 값을 읽는데 최고이다.
연결리스트에서는 원소가 이웃하고 있지 않아서 몇번째 원소가 어디에 있는지 바로 계산할 수 없다.

### `리스트의 가운데에 삽입하기`
원소를 배열이나 리스트의 중앙에 삽입한다면 어느 것이 나을까
리스트는 이전 원소가 무엇을 가리키는지 바꾸기만 하면 되므로 리스트에 삽입하는 것이 훨씬 쉽다.
배열에서는 다음에 오는 모든 원소의 위치를 바꿔야 한다.
만약 공간이 부족하면 모든 원소를 새로운 장소로 복사해야 한다.
그래서 중간에 원소를 삽입하려면 리스트가 훨씬 낫다.

### `삭제하기`
원소를 삭제할 때도 이전 원소가 라기키는 위치만 바꾸면 되기 때문에 리스트가 더 낫다
배열에서는 원소 하나만 삭제하고 싶을 때도 모든 것을 다 옮겨야 한다.
삽입할 때와 달리 삭제할 때는 실패하는 경우가 없다.
삽입할 때는 가끔 메모리에 남아있는 공간이 없어서 실패할 수도 있다.
하지만 삭제는 언제든 가능하다.

|    |배열   | 리스트 |
|읽기 | O(1) | O(n) | 
|삽입 | O(n) | O(1) |
|삭제 | O(n) | O(1) |

연결 리스트에서는 첫번째 원소와 마지막 원소는 바로 접근이 가능하기 때문에 지우는데 O(1)시간만 걸린다.
경우에 따라서 배열과 리스트를 사용하겠지만, 배열에서는 임의의 원소에 접근하는 것이 가능하기 때문에 배열을 쓰는 경우가 많다.

자료의 접근 방식에는 임의 접근과 순차 접근이 있다.
순차 접근은 원소를 첫번째부터 하나씩 읽는 것을 뜻한다. 연결 리스트는 순차 접근 밖에 할 수 업다.
반면에 임의 접근은 10번째 원소로 바로 건너뛸 수 있다. 배열에서는 임의접근이 가능하기 때문에 읽기 속도가 빠르다.
임의 접근을 필요로 하는 경우가 많기 때문에 배열을 사용하는 경우가 많다.

## `선택정렬`
컴퓨터에 음악이 많이 저장되어있다고 하자.
가수별로 몇곡이 저장되어있는지 다음과 같이 기록하였다.
|가수 명     | 저장된 노래 수 |
|----------|-------------|
|아이유      | 50          |
|볼빨간 사춘기 | 10          |
|악동 뮤지션  | 15          |
|스탠딩 에그  | 8           |

가장 많이 저장된 순서로 정렬하고 싶다면 어떻게 해야할까?
한가지 방법은 리스트의 모든 항목을 살펴보고 저장된 노래 수가 가장 많은 가수를 찾아 새로운 리스트에 작성하는 것이다.

아이유의 노래가 가장많이 저장되었다.
|가수 명     | 저장된 노래 수 |
|----------|-------------|
|아이유      | 50          |

그 다음, 악동 뮤지션 노래가 가장 많이 저장되었다.
|가수 명     | 저장된 노래 수 |
|----------|-------------|
|아이유      | 50          |
|악동 뮤지션  | 15          |

이렇게 반복하면 정렬된 목록을 얻을 수 있다.
|가수 명     | 저장된 노래 수 |
|----------|-------------|
|아이유      | 50          |
|악동 뮤지션  | 15          |
|볼빨간 사춘기 | 10          |
|스탠딩 에그  | 8           |

이런식으로 목록을 정렬해나간다면, 목록의 모든 항목을 점검해야 하므로 O(n) 시간이 걸린다.
0(n)시간이 걸리는 연산을 n번 수행해야 하니까 모두 합해서 O(n x n)시간, 즉 O(n2)시간이 걸린다.(n제곱)
선택정렬은 깔끔하지만 빠르지는 않은 알고리즘이라고 할 수 있다.

## `Summary`
* 컴퓨터 메모리는 거대한 서랍장과 같다.
* 여러 개의 항목을 저장하고 싶을 때는 배열이나 리스트를 사용한다.
* 배열을 쓰면 모든 항목은 이웃하는 위치에 저장된다.
* 리스트를 쓰면 모든 항목이 흩어지지만, 각 항목은 다음 항목의 주소를 저장하고 있다.
* 배열은 읽기가 빠르다.
* 연결 리스트는 삽입과 삭제가 빠르다.
* 배열의 모든 원소는 같은 자료형(예를 들면, 모두 정수형이거나 모두 실수형)이어야 한다.