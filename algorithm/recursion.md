# `재귀`
창고를 뒤지다가 자물쇠가 걸려있는 다이어리를 발견했다.
초등학생 때 썼던 다이어리로, 열쇠는 다른 상자에 넣어서 보관하고 있었다.
큰 상자 속에는 작은 상자들이 있고, 그 작은 상자들 안에는 더 작은 상자들이 있다.
열쇠는 그 상자 속 어딘가에 있다. 열쇠를 찾기 위한 알고리즘은 어떻게 될까?

## `첫번째 방법`
1. 내부를 확인할 상자를 쌓아놓는다.
2. 상자를 하나씩 집어서 내부를 살핀다
3. 만약에 안에 작은 상자가 또 있다면 꺼내어 나중에 확인할 상자 더미에 놓는다.
4. 만약 열쇠가 있으면 작업 종료
5. 반복한다.

## `두번째 방법`
1. 상자 안을 확인한다.
2. 만약에 작은 상자가 또 들어있다면 1단계로 간다.
3. 만약에 열쇠를 발견하면 작업 종료

첫번째 방법은 While문을 사용한다.
상자더미가 남아있을 때 까지 확인하는 것이다.

<첫번째 방법의 의사코드(Pseudocode)>  
***의사코드(Pseudocode): 문제와 풀이 방법을 간단한 코드 형태로 표현한 것***
~~~
public void lookingForKey() {
    List<Box> boxPile = new ArrayList<>();

    while(boxPile.length() > 0) {
        for(Box box : boxPile) {
            if(box.existBox()) boxPile.add(box);
            else if(box.existKey()) System.out.println("열쇠 찾음");
        }
    }
}
~~~

두번째 방법은 재귀를 사용한다.
재귀란, `자기 자신을 호출`하는 문제해결 알고리즘이다.
~~~
public void lookingForKey(Box box) {
    for(Item item : box) {
        if(item.isBox) lookingForKey(item);
        else if(item.isKey) System.out.println("열쇠 찾음");
    }
}
~~~

재귀는 풀이를 더 명확하게 만들어준다.
성능이 더 나아지는 것은 아니고, 오히려 반복문이 성능이 더 좋은 경우가 많다.

## `기본 단계와 재귀 단계`
재귀함수는 자기 자신을 호출하기 때문에 무한 반복을 하는 함수를 만들기 쉽다.
예를 들어 다음과 같이 카운트다운을 하는 함수를 만든다고 해보자.
5, 4, ... 1

다음과 같은 함수로 이를 실행할 수 있다.
~~~
public void countdown(int i) {
    System.out.print(i);
    countdown(i-1);
}
~~~

이 코드는 실행시키면 함수가 끊임없이 실행된다는 것을 알 수 있다.
5, 4, 3, 2, 1, 0, -1, -2 ...

`재귀함수를 만들 때는 언제 재귀를 멈출지 알려줘야 한다.`
그래서 모든 재귀함수는 `기본단계(base case)`와 `재귀단계(recursive case)`라는 두 부분으로 나누어져 있다.
* 기본단계 : 자기 자신을 다시 호출하지 않는 경우를 지정. 즉, 무한 반복에 빠지지 않도록 함.
* 재귀단계 : 자기 자신을 호출하는 부분.

기본단계를 추가하면 다음과 같이 된다.
~~~
public void countdown(int i) {
    System.out.print(i);

    if(i > 1) { // 재귀가 실행될 조건을 지정함
        countdown(i-1); // 재귀단계
    }
}
~~~

## 스택
쌓여진 그릇같은 형태로 그릇을 추가할 때는 가장 위에 그릇을 얹어 쌓는다. (Push)
설거지를 할 때는 가장 위에 있는 접시부터 꺼내어 설거지 한다. (Pop)

이와 같이 스택은 아주 간단한 자료구조를 가지고 있다.

### `호출스택`
컴퓨터는 호출 스택이라는 스택을 사용한다. 
어떻게 사용하는지 다음의 예제를 통해 살펴보자.

public class StackTest {

    public void main(String[] args) {
        greet("홍길동");
    }

    public void greet(String name) {
        System.out.println("안녕하세요, " + name + " 님!");
        greet2(name);

        System.out.println("작별인사 준비");
        bye();
    }

    public void greet2(String name) {
        System.out.println("어떻게 지내세요, " + name + " 님!");
    }

    public void bye() {
        System.out.println("안녕히 가세요!");
    }
}

greet("홍길동")이라고 명령했다고 가정하자.
그러면 컴퓨터는 이 함수 호출을 위해 매모리 상자를 하나 할당한다.
|                        |
|------------------------|
| 메모리                   |

할당 받은 메모리에 name이라는 변수값 "홍길동"을 사용하는 greet 메소드를 저장한다.
|                         |
|-------------------------|
| greet() : name - "홍길동" |

함수를 호출할 때 마다 컴퓨터는 호출에 사용된 변수의 값을 모두 저런 식으로 저장한다.
안녕하세요, 홍길동 님! 이라고 프린트 한 후, greet2("홍길동") 명령으로 다른 함수를 호출한다.
이번에도 컴퓨터는 함수 호출에 필요한 또 다른 메모리 상자를 할당한다.

| greet2() : name - "홍길동"|
|-------------------------|
| greet() : name - "홍길동" |

컴퓨터는 이런 메모리 상자를 스택으로 사용한다. 두번째 상자는 첫번째 상자 위에 올려진 상태이다.
어떻게 지내세요, 홍길동 님!이라고 프린트 하고, 함수 호출 상태에서 반환(return)하여 돌아와야 한다.
함수가 반환되면 가장 위에 있는 상자는 팝(POP)연산으로 인해 없어진다.

|                         |
|-------------------------|
| greet() : name - "홍길동" |

스택에서 가장 위에 있는 함수는 greet 함수가 된다. 즉, 다시 greet 함수로 돌아왔다는 뜻이다.
greet2 함수를 호출했을 때 greet 함수는 아직 완전히 실행되지 않은 상태였다.
어떤 함수를 호출하여 완전히 실행을 완료하기 전이라도, 그 함수를 멈추고 다른 함수를 호출할 수 있다.
중지된 함수의 변수 값들은 모두 메모리에 저장되어 있다.
greet2 함수의 실행을 완료하고 나면 greet 함수로 돌아가 멈추었던 위치에서 다시 실행할 수 있다.작별인사 준비라고 프린트 한 뒤 bye 함수를 실행한다.

| bye()                   |
|-------------------------|
| greet() : name - "홍길동" |

새로운 함수를 위한 메모리 상자가 스택 위에 더해진다.
안녕히 가세요!라고 프린트한 다음, 다시 함수호출로 돌아온다.

|                         |
|-------------------------|
| greet() : name - "홍길동" |

더 이상 실행할 것이 없으므로 greet 함수에서도 반환하여 돌아온다.
이런 방식으로 여러 개의 함수를 호출하면서 함수에 이용되는 변수를 저장하는 스택을 호출 스택(call stack)이라고 한다.

### `재귀함수에서 호출 스택 사용`
재귀함수도 호출 스택을 사용한다.
팩토리얼 함수가 어떻게 동작하는지 살펴보자.
팩토리얼 5는 5!라는 뜻이고, 5 x 4 x 3 x 2 x 1 로 정의되는 값이다.
마찬가지로 팩토리얼 3은 3!이라는 뜻이고, 3 x 2 x 1로 정의된다.

~~~
public int factorial(int x) {
    if(x == 1) {
        return 1;
    } else {
        return x * factorial(x-1);
    }
}
~~~

factorial(3)을 호출한다고 해보자.

컴퓨터는 이 함수 호출을 위해 매모리 상자를 하나 할당한다.
|                        |
|------------------------|
| 메모리                   |

할당 받은 메모리에 변수값 3을 사용하는 factorial 메소드를 저장한다. (첫번째 호출)
|                         |
|-------------------------|
| factorial() : x = 3     |

x가 1이 아니므로, 변수값 2를 사용하는 factorial 메소드를 호출한다. (두번째 호출)
| factorial() : x = 2     |
|-------------------------|
| factorial() : x = 3     |

두 함수 모두 x라는 이름의 변수를 가지고 있지만 x값은 다르다.
다른 호출에 대한 x값에는 접근 할 수 없다.
x가 1이 아니므로, 변수값 1을 사용하는 factorial 메소드를 호출한다. (세번째 호출)
| factorial() : x = 1     |
|-------------------------|
| factorial() : x = 2     |
|-------------------------|
| factorial() : x = 3     |

가장 위에 있는 함수, 현재 실행하고 있는 호출이다.
factorial 메소드를 세번 호출했지만, 아직 함수 호출을 하나도 끝내지 못했다.
스택에서 팝(Pop)하여 맨 위에 있는 함수를 호출한다.  
***return 1***
| factorial() : x = 2     |
|-------------------------|
| factorial() : x = 3     |

스택에서 팝(Pop)하여 맨 위에 있는 함수를 호출한다. 
***return 2 * factorial(1)***
|                         |
|-------------------------|
| factorial() : x = 3     |

스택에서 팝(Pop)하여 맨 위에 있는 함수를 호출한다. 
***return 3 * factorial(2)***

즉, 해당 메소드는 3 * 2 * 1을 반환한다.

스택을 사용하면 편리하긴 하지만 그만큼의 대가를 치러야 한다.
모든 메모리를 저장해야 하므로 메모리르 많이 소비한다.
함수 호출을 할때마다 메모리를 사용하게 된다.
스택이 너무 커졌다는 것은 컴퓨터가 과다한 함수호출 정보를 저장하고 있다는 뜻이다.

## `Summary`
* 재귀는 함수가 스스로 호출하는 것이다.
* 모든 재귀 함수는 기본 단계와 재귀 단계라는 두 부분으로 나누어져 있다.
* 스택에는 푸쉬(Push)와 팝(Pop)이라는 두가지 연산이 있다.
* 모든 함수 호출은 호출 스택을 사용한다.
* 호출 스택은 너무 커져서 메모리를 엄청나게 사용할 수도 있다.