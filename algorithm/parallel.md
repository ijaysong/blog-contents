# 병렬 알고리즘
여러개의 동작이 동시에 실행될 수 있도록 하는 알고리즘이다.
병렬 알고리즘은 설계하기가 어렵다.
올바르게 동작하는지, 어느 정도의 속도 향상을 얻을 수 있는지 정확하게 파악하기 어렵다.
한가지 확실한 것은 속도 향상이 선형적이지 않다는 것이다.
한개의 코어가 아니라 두개의 코어에서 돌린다 하더라도 마법처럼 두 배로 빨라지지 않는다. 
이렇게 되는데에는 몇 가지 이유가 있다.

* `병렬화를 관리하는데 들어가는 부담` : 만약 1,000개의 항목을 가지는 배열을 정렬한다고 할 떄, 이 작업을 어떻게 두 개의 코어가 처리하도록 나눌까? 각각의 코어가 500개의 항목을 정한 다음 정렬된 두개의 배열을 하나의 큰 정렬 배열로 합칠 것인가? 두 배열을 합치는데도 시간이 걸린다.

* `로드 밸런싱` : 10개의 작업을 해야 해서 두 개의 코어에 5개씩 작업을 나누어 주었다. 그런데 A 코어는 쉬운 일만 받아서 10초 내에 끝내고, B 코어는 어려운 일만 받아서 모든 작업을 하는 데 1분이 걸렸다 이렇게 되면 50초 동안 B 코어 혼자 열심히 일을 하고 A 코어는 놀기만 한다. 두개의 코어에 일을 균등하게 배분하려면 어떻게 해야할까?

## 맵리듀스
병렬 알고리즘 중 하나인 `분산 알고리즘`이다.
코어가 두개나 네개 정도 필요하다면 노트북에서 병렬 알고리즘을 돌려도 된다. 
하지만 수백개의 코어가 필요하다면? 여러 대의 컴퓨터에서 돌아가는 분산 알고리즘을 만들어야 한다. 
아파치 하둡과 같은 오픈 소스 툴을 통해 맵리듀스 알고리즘을 사용할 수 있다.

### 분산 알고리즘이 유용한 이유
수십억 개의 레코드를 가지는 DB에서 SQL문을 돌리면 시간이 매우 많이 걸린다.
이럴때 하둡에서 맵리듀스를 사용하면 된다.
분산 알고리즘은 이렇게 많은 작업을 하면서 실행 시간을 단축시키고 싶을 때 유용하다.
맵리듀스는 맵 함수와 리듀스 함수라는 두개의 간단한 개념을 이용해서 만들어졌다.

### 맵 함수
맵 함수는 배열을 입력받아서 배열의 모든 원소에 같은 함수를 적용한다.
예를 들어 다음과 같이 배열의 모든 원소의 값을 두 배로 많드는 경우를 살펴보자.

~~~
>>> arr1 = [1, 2, 3, 4, 5]
>>> arr2 = map(lambda x : 2*x, arr1)
[2, 4, 6, 8, 10]
~~~

시간이 더 걸리는 함수를 살펴보자.
~~~
>>> arr1 = # A list of URLs
>>> arr2 = map(download_page, arr1)
~~~

일련의 URL을 넣어주면 각 페이지를 다운로드해서 그 내용을 arr2에 저장한다.
하나의 URL을 작업하는데 몇 초 밖에 걸리지 않겠지만, URL이 1,000개 있다면 몇 시간이 걸린다.
만약 100개의 컴퓨터가 있다면 맵 함수는 이 작업을 모든 컴퓨터에 골고루 배분한다.
그러면 한번에 100개의 페이지를 다운로드 할 수 있고 작업이 훨씬 빨라진다.
이것이 맵리듀스에서 맵 함수의 개념이다.

### 리듀스 함수
리튜스 함수는 리스트 전체의 원소를 하나의 원소로 축소하는 것이다.
맵 함수에서는 하나의 배열에서 같은 크기의 다른 배열을 얻었다.
리듀스에서는 이 배열을 하나의 원소로 변형한다.

<맵 함수>
| 1 | 2 | 3 | 4 | 5  |
|---|---|---|---|----|
| 2 | 4 | 6 | 8 | 10 |

<리듀스 함수>
| 1 | 2 | 3 | 4 | 5 |
|---|---|---|---|---|
| 15                |

이 경우에는 모든 원소를 더하여 15가 반환된다. (1 + 2 + 3 + 4 + 5)

맵리듀스는 이 두 가지의 개념을 이용해서 어러 대의 컴퓨터에 분산되어 있는 데이터에 대한 질의를 수행한다.
맵리듀스는 데이터가 수십억 개의 레코드로 이루어져 있더라도 일반 데이터베이스에서 몇 분만에 수행할 수 있다.
