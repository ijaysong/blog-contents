# 그리디 알고리즘 (Greedy Algorithm)
탐욕 알고리즘이라고도 하고, 욕심쟁이 알고리즘이라고도 불린다.  
가장 직관적인 알고리즘 중 하나로, 각 단계마다 지금 당장 가장 좋은 방법만을 선택한다.  
지금의 선택이 앞으로 남은 선택들에 어떤 영향을 끼칠지는 고려하지 않는다.  

`‘그렇게 간단한 방법으로 답이 나올까?’`

물론 정답이 나올리 없다!  
그리디 탐욕법은 많은 경우 최적해를 찾지 못한다. 따라서 사용되는 경우는 크게 다음 2가지로 제한된다.  

* 탐욕법을 사용해도 항상 최적해를 구할 수 있는 문제를 만난 경우 <br>
→ 탐욕법은 동적 계획법보다 수행시간이 훨씬 빠르기때문에 유용하다.

* 시간이나 공간적 제약으로 인해 다른 방법으로 최적해를 찾기 너무 어렵다면 최적해 대신 적당히 괜찮은 답(근사해)를 찾는 것으로 타협할 수 있음.  <br>
→ 이럴 때 탐욕법은 최적은 아니지만 임의의 답보다는 좋은 답을 구하는 용도로 유용하게 쓰인다.

그리디 알고리즘은 프로그래밍 대회나 코딩테스트에서 주로 첫번째 용도로만 사용된다.  
근사해를 찾는 문제가 거의 출제 되지 않을 뿐더러, 가끔 근사해를 찾는 문제가 출제 되더라도 조합탐색이나 메타휴리스틱 알고리즘들이 더 좋은 답을 주기 때문이다.

탐욕법은 개념은 간단하지만, 은근히 발목을 잡는 주제 중 하나이다.  
한 문제를 탐욕적으로 해결하는 방법이 한 가지만 있는 것이 아닌 경우도 많은데, 이 중 어느 방법을 선택해야 최적해를 구할 수 있을지 알아내기가 어렵기 때문이다.  
그러니 그리디 알고리즘 연습 문제를 풀 때는 알고리즘의 정당성을 증명하는 과정을 빼먹지 않고 연습하는 것이 좋다.

<정당성의 증명>
* 탐욕적 선택 속성 (greedy choice property) <br>
→ 해당 속성이 성립할 경우, 각 단계에서 탐욕적으로 내리는 선택은 항상 최적해로 가는 길이 된다. 
* 최적 부분 구조 (optimal substructure) <br>
→ 부분 문제의 최적해에서 전체 문제의 최적해를 만들 수 있음을 증명해야 한다. 다행히 이 속성은 대개 매우 자명해서 따로 증명할 필요가 없는 경우가 대부분이다.

