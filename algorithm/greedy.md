# 그리디 알고리즘 (Greedy Algorithm)
탐욕 알고리즘이라고도 하고, 욕심쟁이 알고리즘이라고도 불린다.  
가장 직관적인 알고리즘 중 하나로, 각 단계마다 지금 당장 가장 좋은 방법만을 선택한다.  
지금의 선택이 앞으로 남은 선택들에 어떤 영향을 끼칠지는 고려하지 않는다.  

`‘그렇게 간단한 방법으로 답이 나올까?’`

물론 정답이 나올리 없다!  
그리디 탐욕법은 많은 경우 최적해를 찾지 못한다. 따라서 사용되는 경우는 크게 다음 2가지로 제한된다.  

* 탐욕법을 사용해도 항상 최적해를 구할 수 있는 문제를 만난 경우 <br>
→ 탐욕법은 동적 계획법보다 수행시간이 훨씬 빠르기때문에 유용하다.

* 시간이나 공간적 제약으로 인해 다른 방법으로 최적해를 찾기 너무 어렵다면 최적해 대신 적당히 괜찮은 답(근사해)를 찾는 것으로 타협할 수 있음.  <br>
→ 이럴 때 탐욕법은 최적은 아니지만 임의의 답보다는 좋은 답을 구하는 용도로 유용하게 쓰인다.

그리디 알고리즘은 프로그래밍 대회나 코딩테스트에서 주로 첫번째 용도로만 사용된다.  
근사해를 찾는 문제가 거의 출제 되지 않을 뿐더러, 가끔 근사해를 찾는 문제가 출제 되더라도 조합탐색이나 메타휴리스틱 알고리즘들이 더 좋은 답을 주기 때문이다.

탐욕법은 개념은 간단하지만, 은근히 발목을 잡는 주제 중 하나이다.  
한 문제를 탐욕적으로 해결하는 방법이 한 가지만 있는 것이 아닌 경우도 많은데, 이 중 어느 방법을 선택해야 최적해를 구할 수 있을지 알아내기가 어렵기 때문이다.  
그러니 그리디 알고리즘 연습 문제를 풀 때는 알고리즘의 정당성을 증명하는 과정을 빼먹지 않고 연습하는 것이 좋다.

예를 들어, 다음 문제를 그리디 알고리즘으로 풀어보자.

~~~
백준알고리즘 11399번
사람들이 줄을 서는 순서에 따라서, 돈을 인출하는데 필요한 시간의 합이 달라지게 된다.  
예를 들어, 총 5명이 있고, P1 = 3, P2 = 1, P3 = 4, P4 = 3, P5 = 2 인 경우를 생각해보자.  
[1, 2, 3, 4, 5] 순서로 줄을 선다면, 1번 사람은 3분만에 돈을 뽑을 수 있다.  
2번 사람은 1번 사람이 돈을 뽑을 때 까지 기다려야 하기 때문에, 3+1 = 4분이 걸리게 된다.  
3번 사람은 1번, 2번 사람이 돈을 뽑을 때까지 기다려야 하기 때문에, 총 3+1+4 = 8분이 필요하게 된다.  
4번 사람은 3+1+4+3 = 11분, 5번 사람은 3+1+4+3+2 = 13분이 걸리게 된다. 
이 경우에 각 사람이 돈을 인출하는데 필요한 시간의 합은 3+4+8+11+13 = 39분이 된다.  
줄을 서 있는 사람의 수 N과 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어졌을 때, 
각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 구하는 프로그램을 작성하시오.  
~~~

<정당성의 증명>
* 탐욕적 선택 속성 (greedy choice property) <br>
→ 해당 속성이 성립할 경우, 각 단계에서 탐욕적으로 내리는 선택은 항상 최적해로 가는 길이 된다. 
→ `각 단계를 돌며 걸리는 시간이 가장 적은 돈을 인출하는데 걸리는 시간이 가장 적은 최적해가 반드시 존재한다.`
* 최적 부분 구조 (optimal substructure) <br>
→ 부분 문제의 최적해에서 전체 문제의 최적해를 만들 수 있음을 증명해야 한다. 다행히 이 속성은 대개 매우 자명해서 따로 증명할 필요가 없는 경우가 대부분이다.

