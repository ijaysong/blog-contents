# 그리디 알고리즘 (Greedy Algorithm)
탐욕 알고리즘이라고도 하고, 욕심쟁이 알고리즘이라고도 불린다.  
가장 직관적인 알고리즘 중 하나로, 각 단계마다 지금 당장 가장 좋은 방법만을 선택한다.  
지금의 선택이 앞으로 남은 선택들에 어떤 영향을 끼칠지는 고려하지 않는다.  

## 수업 시간표 짜기 문제
학교에서 되도록 많은 수업을 듣고 싶다.
어떤 과목들을 신청해야 가장 많은 수업을 들을 수 있을까?

|수업   | 시작 | 종료  |
|------|-----|------|
|미술   |9:00 |10:00 |
|영어   |9:30 |10:30 |
|수학   |10:00|11:00 |
|컴퓨터 |10:30 |11:30 |
|음악   |11:00 |12:00 |

1. 가장 빨리 끝나는 과목을 고른다.
2. 첫번째 과목이 끝난 후 시작하는 과목을 고르는데, 마찬가지로 가장 빨리 끝나는 과목을 고른다.
이런 식으로 반복하면 정답을 얻을 수 있다.

미술이 오전 10시에 끝나니까 가장 빨리 끝나는 과목이다. 미술을 가장 먼저 신청한다.
|수업   | 시작 | 종료  |
|------|-----|------|
|미술   |9:00 |10:00 |

오전 10시 이후에 시작하고, 가장 빨리 끝나는 수업을 고른다.
영어는 미술시간과 겹치므로 안되고, 수학을 선택한다.
|수업   | 시작 | 종료  |
|------|-----|------|
|미술   |9:00 |10:00 |
|수학   |10:00|11:00 |

마지막 단계로 컴퓨터는 수학시간과 겹치므로 음악을 고른다.
|수업   | 시작 | 종료  |
|------|-----|------|
|미술   |9:00 |10:00 |
|수학   |10:00|11:00 |
|음악   |11:00 |12:00 |

결과적으로 신청해야 할 과목은 `미술, 수학, 음악`이다.
각각의 단계에서 최적의 수를 찾아내는 알고리즘의 간단함이 탐욕 알고리즘의 장점이다.
이 간단한 알고리즘으로 수업 시간표 짜리 문제의 최적해를 구할 수 있다.

## 배낭 채우기 문제
배낭이 하나 있는데, 그 배낭에는 총 35kg까지만 담을 수 있다.
배낭에 넣을 물건 가격의 합을 최대한으로 하고 싶다.
탐욕 알고리즘을 쓰면 간단해진다.

1. 가방에 들어갈 수 있는 것 중에서 가장 비싼 물건을 고른다.
2. 그 다음으로 가방에 들어갈 수 있는 물건 중에서 가장 비싼 것을 고른다. 이것을 반복한다.

하지만 이번에는 알고리즘이 제대로 동작하지 않는다.
|물건명   | 가격   | 무게  |
|-------|-------|------|
|스테레오 | 3,000 | 30kg |
|노트북   | 2,000 | 20kg |
|기타    | 1,500 | 15kg |

배낭에는 35kg까지만 들어간다.
스테레오가 가장 비싸니까 스테레오를 담으면 다른 것을 넣을 수 없다. (5kg 비었음)
스테레오의 가치는 3,000달러 이지만, 대신에 노트북과 기타를 같이 담으면 총 가치는 3,500달러가 된다.

탐욕 알고리즘은 올바른 답을 내놓지 못했다.
하지만 정답에 상당히 가까운 답이였다.

## 집합 커버링 문제
라디오 쇼를 시작했다고 가정해보자.
전국 8도에 있는 모든 사람에게 이 라디오 쇼를 들려주고 싶다.
하나의 방송국을 통해 청취할 수 있는 지역이 한정되어 있기 때문에 전국에 흩어져 있는 몇 개의 라디오 방송국들을 방문해서 라디오 쇼를 진행할 예정이다.
방송국을 방문하여 한번 쇼를 하는데 돈이 들기 때문에 최대한 적은 수의 방송국을 돌아야한다.

방송국 목록은 다음과 같다.
|라디오 방송국 | 청취 가능한 도             |
|-----------|------------------------|
|KONE       | 서울특별시, 경기도, 강원도   |
|KTWO       | 강원도, 충청남도, 충청북도   |
|KTHREE     | 경상남도, 경상북도, 전라남도 |
|KFOUR      | 전라남도, 전라북도, 제주도   |
|KFIVE      | 제주도, 전라남도           |

각 방송국마다 커버할 수 있는 지역이 서로 다르고 겹치는 지역이 있을 수 있다.
전국 8도 전체를 커버하는 가장 적은 수의 방송국의 집합은 어떻게 구해야 할까?
이 문제는 엄청나게 어려운 문제이다.
다음과 같이 답을 구해보자.

1. 가능한 모든 방송국의 부분집합을 나열한다. 이것을 멱집합(power set)이라고 한다.
   가능한 부분 집합의 수는 2의 n제곱이다.
2. 이 부분 집합 중에 50개 주 전체를 커버할 수 있으면서 가장 원소의 수가 적은 부분 집합을 고른다.

문제는 모두 가능한 부분집합을 계산하는데 시간이 많이 걸린다는 것이다.
부분집합의 수가 2의 n제곱이기 때문에 O(2의 n제곱) 시간이 걸린다.
항목의 수가 늘어가면 전체 실행 시간도 크게 증가하는 케이스이다.

## 근사 알고리즘
다음과 같은 탐욕 알고리즘은 거의 정답과 비슷한 답을 유추한다.

1. 아직 방송하지 않는 지역 중 가장 많은 지역에 방송할 수 있는 방송국을 고른다. 
   (이미 방송되고 있는 지역이 일부 포함되어 있어도 상관 없음.)
2. 모든 주에 방송이 될 때까지 선택을 반복한다.

이것을 `근사 알고리즘`이라고 한다.
정확한 답을 계산하는데 시간이 너무 많이 걸린다면 근사 알고리즘을 사용할 수 있다.
근사 알고리즘의 성능은 다음 두가지로 판단한다.

* 얼마나 빠른가
* 최적해에 얼마나 가까운가

탐욕 알고리즘은 다루기 간단할 뿐더러 그 단순함으로 인해 실행속도가 빠르기 때문에 좋은 선택이 될 수 있다.
이 경우에 탐욕 알고리즘의 실행속도는 O(n의 2제곱) 시간이다.
여기서 n은 방송국의 수이다.

### 준비 코드
Set을 사용해 방송하고자 하는 주의 목록을 만든다.
집합 타입은 리스트와 비슷하지만 각 원소가 한번씩만 나타난다.
즉, 중복된 원소를 가지지 않는다.
~~~
HashSet<String> areaNeeded = new HashSet<>();
areaNeeded.add("Seoul"); // 서울특별시
areaNeeded.add("Kyungi-do"); // 경기도
areaNeeded.add("Kangwon-do"); // 강원도
areaNeeded.add("Choongchungnam-do"); // 충청남도
areaNeeded.add("Choongchungbuk-do"); // 충청북도
areaNeeded.add("Kyungsangnam-do"); // 경상남도
areaNeeded.add("Kyungsangbuk-do"); // 경상북도
areaNeeded.add("Jeonlanam-do"); // 전라남도
areaNeeded.add("Jeonlabuk-do"); // 전라북도
areaNeeded.add("Jeju-do"); // 제주도
~~~

그리고 선택된 방송국의 목록을 저장한다.
이 목록을 저장하는 데는 해시 테이블을 사용한다.

~~~
HashMap<String, Set<String>> stations = new HashMap<>();
stations.put("kone", Arrays.asList("Seoul", "Kyungi-do", "Kangwon-do").stream().collect(Collectors.toSet()));
stations.put("ktwo", Arrays.asList("Kangwon-do", "Choongchungnam-do", "Choongchungbuk-do").stream().collect(Collectors.toSet()));
stations.put("kthree", Arrays.asList("Kyungsangnam-do", "Kyungsangbuk-do", "Jeonlanam-do").stream().collect(Collectors.toSet()));
stations.put("kfour", Arrays.asList("Jeonlanam-do", "Jeonlabuk-do", "Jeju-do").stream().collect(Collectors.toSet()));
stations.put("kfive", Arrays.asList("Jeju-do", "Jeonlanam-do").stream().collect(Collectors.toSet()));
~~~

마지막으로 방문할 방송국의 목록을 저장할 집합이 필요하다.
~~~
HashSet<String> finalStations = new HashSet<>();
~~~

### 답을 계산하기
모든 방송국을 하나씩 보면서 아직 방송이 되지 않은 지역 중에서 가장 많은 지역을 커버하고 있는 방송국을 고른다.
이 방송국을 bestStation이라고 한다.
~~~
String bestStation = ""; // 방송이 되지 않은 지역 중에서 가장 많은 지역을 커버하는 방송국
Set<String> areaCovered = null; // 방송이 된 지역
for(String station : stations.keySet()) {
    // 아직 방송되지 않은 지역 중에서 해당 방송국이 커버하는 지역의 교집합을 구한다
    HashSet<String> covered = new HashSet<>();
    Iterator<String> sn = areaNeeded.iterator();
    while(sn.hasNext()) {
        Set<String> stationArr = stations.get(station);
        if(stationArr.contains(sn.next())) covered.add(sn.next());
    }
    
    if(covered.size() > areaCovered.size()) {
        bestStation = station;
        areaCovered = covered;
    }
}
~~~

`‘그렇게 간단한 방법으로 답이 나올까?’`

물론 정답이 나올리 없다!  
그리디 탐욕법은 많은 경우 최적해를 찾지 못한다. 따라서 사용되는 경우는 크게 다음 2가지로 제한된다.  

* 탐욕법을 사용해도 항상 최적해를 구할 수 있는 문제를 만난 경우 <br>
→ 탐욕법은 동적 계획법보다 수행시간이 훨씬 빠르기때문에 유용하다.

* 시간이나 공간적 제약으로 인해 다른 방법으로 최적해를 찾기 너무 어렵다면 최적해 대신 적당히 괜찮은 답(근사해)를 찾는 것으로 타협할 수 있음.  <br>
→ 이럴 때 탐욕법은 최적은 아니지만 임의의 답보다는 좋은 답을 구하는 용도로 유용하게 쓰인다.

그리디 알고리즘은 프로그래밍 대회나 코딩테스트에서 주로 첫번째 용도로만 사용된다.  
근사해를 찾는 문제가 거의 출제 되지 않을 뿐더러, 가끔 근사해를 찾는 문제가 출제 되더라도 조합탐색이나 메타휴리스틱 알고리즘들이 더 좋은 답을 주기 때문이다.

탐욕법은 개념은 간단하지만, 은근히 발목을 잡는 주제 중 하나이다.  
한 문제를 탐욕적으로 해결하는 방법이 한 가지만 있는 것이 아닌 경우도 많은데, 이 중 어느 방법을 선택해야 최적해를 구할 수 있을지 알아내기가 어렵기 때문이다.  
그러니 그리디 알고리즘 연습 문제를 풀 때는 알고리즘의 정당성을 증명하는 과정을 빼먹지 않고 연습하는 것이 좋다.

예를 들어, 다음 문제를 그리디 알고리즘으로 풀어보자.

~~~
백준알고리즘 11399번
사람들이 줄을 서는 순서에 따라서, 돈을 인출하는데 필요한 시간의 합이 달라지게 된다.  
예를 들어, 총 5명이 있고, P1 = 3, P2 = 1, P3 = 4, P4 = 3, P5 = 2 인 경우를 생각해보자.  
[1, 2, 3, 4, 5] 순서로 줄을 선다면, 1번 사람은 3분만에 돈을 뽑을 수 있다.  
2번 사람은 1번 사람이 돈을 뽑을 때 까지 기다려야 하기 때문에, 3+1 = 4분이 걸리게 된다.  
3번 사람은 1번, 2번 사람이 돈을 뽑을 때까지 기다려야 하기 때문에, 총 3+1+4 = 8분이 필요하게 된다.  
4번 사람은 3+1+4+3 = 11분, 5번 사람은 3+1+4+3+2 = 13분이 걸리게 된다. 
이 경우에 각 사람이 돈을 인출하는데 필요한 시간의 합은 3+4+8+11+13 = 39분이 된다.  
줄을 서 있는 사람의 수 N과 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어졌을 때, 
각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 구하는 프로그램을 작성하시오.  
~~~

<정당성의 증명>
* 탐욕적 선택 속성 (greedy choice property) <br>
→ 해당 속성이 성립할 경우, 각 단계에서 탐욕적으로 내리는 선택은 항상 최적해로 가는 길이 된다. 
→ `각 단계를 돌며 걸리는 시간이 가장 적은 돈을 인출하는데 걸리는 시간이 가장 적은 최적해가 반드시 존재한다.`
* 최적 부분 구조 (optimal substructure) <br>
→ 부분 문제의 최적해에서 전체 문제의 최적해를 만들 수 있음을 증명해야 한다. 다행히 이 속성은 대개 매우 자명해서 따로 증명할 필요가 없는 경우가 대부분이다.

## `Summary`
* 탐욕 알고리즘은 전역 최적화를 목표로 하지만, 실제로는 국소 최적화를 한다.
* NP-완전 문제는 빠른 해답이 알려지지 않았다.
* 만약 NP-완전 문제가 주어지면 근사 알고리즘을 쓰는 것이 최선이다.
* 탐욕 알고리즘은 작성하기도 쉽고 빠르기 때문에 좋은 근사 알고리즘이 될 수 있다.

