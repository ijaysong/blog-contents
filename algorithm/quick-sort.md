# `퀵 정렬`
분할정복은 문제를 더 작은 조각으로 나누어 푼다.
만약 리스트에 분할 정복을 적용한다면, 기본단계는 원소가 없는 빈 배열이거나, 하나의 원소만 가진 배열이 된다.
퀵 정렬을 구현하려면 기준 원소를 무작위로 선택한다.
퀵 정렬의 평균적인 실행시간은 O(n log n)이다.
빅오 표기법에서 가끔씩 상수가 중요해질 때도 있다.
퀵 정렬이 병합 정렬보다 빠른이유도 상수 때문이다.
단순 탐색과 이진 탐색을 비교할 때는 상수항이 전혀 문제가 되지 않는다.
리스트가 길어지만 O(log n)이 O(n)보다 훨씬 빨라지기 때문이다.

## `분할 정복`
사각형 하나 있고, 이를 동일한 크기로 분할한다고 해보자. 크기는 최대로.
다만, 다음과 같이 나누는 것은 안된다.
* 정사각형은 아니다
* 크기가 너무 작다
* 모든 사각형은 같은 크기를 갖는다

어떻게 같은 크기로 사각형을 나눌까?
분할 정복 전략은 재귀적 알고리즘이다.
분할 정복 전략으로 다음과 같이 두가지 단계로 풀어보자.

1. 기본단계를 해결한다. (이 부분은 가능한 한 간단한 문제이어야 한다)
2. 문제가 기본단계가 될때까지 나누거나 작게 만든다.

이 문제에 대해서 분할 정복 전략을 적용해서 가장 큰 정사각형을 찾아보자.
우선, 기본단계를 풀어보자면,
가장 쉬운 기본 단계는 사각형의 한변의 길이가 다른 변의 배수가 되는 경우이다.

이제 재귀단계를 풀어본다. 분할 정복 전략을 적용할 타이밍이다.
분할정복 전략에 따르면 재귀 함수 호출을 할 때마다 문제를 작게 나누어야 한다. 
나누다보면 나머지로 남는 사각형이 있다.
해당 사각형 크기에 맞는 가장 큰 정사각형을 찾으면 이 정사각형으로 사각형 전체를 나눌 수 있다.
-> 유클리드 호제법

분할 정복 전략은 문제에 바로 적용할 수 있는 단순한 알고리즘이 아니다.
그보다는 문제를 풀기 위한 방법론에 가깝다.

예룰 들어 숫자 배열 {2, 4, 6}이 있다고 해보자.
이 숫자들을 모두 더하여 합계를 구해야 한다.
반복문을 사용하면 아주 간단하게 풀린다.
~~~
public void sum(int[] arr) {
    int total = 0;
    for(int i : arr) total += i;
    System.out.println(total);
}
~~~
OUTPUT : 12

재귀함수를 사용해서 합계를 구하려면 어떻게 해야할까?

첫번째, 기본단계 : 가장 간단한 배열인 경우를 찾는다.
원소의 개수가 0개이거나 1개인 배열의 합계를 구하는 것이다.
* 원소의 개수가 0개이면, 합계는 0      ex) {}
* 원소의 개수가 1개이면 {7}, 합계는 7  ex) {7}

두번째, 재귀함수를 호출할 때마다 호출 대상이 되는 배열의 크기가 점점 감소해야 한다.
문제의 크기를 어떻게 줄일 수 있을까
sum({2, 4, 6}) = 12 로 구할 수도 있지만, 2 + sum({4, 6}) = 12로도 구할 수 있다.
어떤 방법을 사용해도 답은 12이지만, 두번째 방법에서는 sum함수에 더 작은 배열을 넘긴다는 점이다.
~~~ 
public int sum(LinkedList<Integer> arr) {
    int length = arr.size();

    if(length == 0) return 0; // 기본단계
    else if(length == 1) return arr.pop();

    return arr.pop() + sum(arr);
}
~~~
