# `퀵 정렬`
분할정복은 문제를 더 작은 조각으로 나누어 푼다.
만약 리스트에 분할 정복을 적용한다면, 기본단계는 원소가 없는 빈 배열이거나, 하나의 원소만 가진 배열이 된다.
퀵 정렬을 구현하려면 기준 원소를 무작위로 선택한다.
퀵 정렬의 평균적인 실행시간은 O(n log n)이다.
빅오 표기법에서 가끔씩 상수가 중요해질 때도 있다.
퀵 정렬이 병합 정렬보다 빠른이유도 상수 때문이다.
단순 탐색과 이진 탐색을 비교할 때는 상수항이 전혀 문제가 되지 않는다.
리스트가 길어지만 O(log n)이 O(n)보다 훨씬 빨라지기 때문이다.

## `분할 정복`
사각형 하나 있고, 이를 동일한 크기로 분할한다고 해보자. 크기는 최대로.
다만, 다음과 같이 나누는 것은 안된다.
* 정사각형은 아니다
* 크기가 너무 작다
* 모든 사각형은 같은 크기를 갖는다

어떻게 같은 크기로 사각형을 나눌까?
분할 정복 전략은 재귀적 알고리즘이다.
분할 정복 전략으로 다음과 같이 두가지 단계로 풀어보자.

1. 기본단계를 해결한다. (이 부분은 가능한 한 간단한 문제이어야 한다)
2. 문제가 기본단계가 될때까지 나누거나 작게 만든다.

이 문제에 대해서 분할 정복 전략을 적용해서 가장 큰 정사각형을 찾아보자.
우선, 기본단계를 풀어보자면,
가장 쉬운 기본 단계는 사각형의 한변의 길이가 다른 변의 배수가 되는 경우이다.

이제 재귀단계를 풀어본다. 분할 정복 전략을 적용할 타이밍이다.
분할정복 전략에 따르면 재귀 함수 호출을 할 때마다 문제를 작게 나누어야 한다. 
나누다보면 나머지로 남는 사각형이 있다.
해당 사각형 크기에 맞는 가장 큰 정사각형을 찾으면 이 정사각형으로 사각형 전체를 나눌 수 있다.
-> 유클리드 호제법

분할 정복 전략은 문제에 바로 적용할 수 있는 단순한 알고리즘이 아니다.
그보다는 문제를 풀기 위한 방법론에 가깝다.

예룰 들어 숫자 배열 {2, 4, 6}이 있다고 해보자.
이 숫자들을 모두 더하여 합계를 구해야 한다.
반복문을 사용하면 아주 간단하게 풀린다.
~~~
public void sum(int[] arr) {
    int total = 0;
    for(int i : arr) total += i;
    System.out.println(total);
}
~~~
OUTPUT : 12

재귀함수를 사용해서 합계를 구하려면 어떻게 해야할까?

첫번째, 기본단계 : 가장 간단한 배열인 경우를 찾는다.
원소의 개수가 0개이거나 1개인 배열의 합계를 구하는 것이다.
* 원소의 개수가 0개이면, 합계는 0      ex) {}
* 원소의 개수가 1개이면 {7}, 합계는 7  ex) {7}

두번째, 재귀함수를 호출할 때마다 호출 대상이 되는 배열의 크기가 점점 감소해야 한다.
문제의 크기를 어떻게 줄일 수 있을까
sum({2, 4, 6}) = 12 로 구할 수도 있지만, 2 + sum({4, 6}) = 12로도 구할 수 있다.
어떤 방법을 사용해도 답은 12이지만, 두번째 방법에서는 sum함수에 더 작은 배열을 넘긴다는 점이다.
~~~ 
public int sum(LinkedList<Integer> arr) {
    int length = arr.size();

    if(length == 0) return 0; // 기본단계
    else if(length == 1) return arr.pop(); // 기본단계

    return arr.pop() + sum(arr); // 재귀함수를 호출할 때마다 범위를 줄여나간다
}
~~~

## `퀵 정렬`
퀵 정렬은 정렬 알고리즘이다.
선택 정렬보다 훨씬 빠르고, 실제로도 자주 사용된다.
퀵 정렬도 마찬가지로 분할 정복 전략이다.

배열을 정렬하기 위해 퀵 정렬을 사용해보자.
정렬하는데 가장 간단한 정렬은 무엇일까?

비어있는(원소가 없는) 배열이거나 원소가 하나인 배열인 경우이다.
해당 경우에는 정렬할 필요가 없다. 그러므로 비어있는 정렬이나 원소가 하나인 배열이 기본단계가 된다.
이때는 배열을 있는 그대로 반환하면 된다.
* 비어있는 배열 []
* 원소가 하나인 배열 [7]
~~~
public int[] quickSort(int[] arr) {
    if(arr.length() < 2) return arr; // 기본 단계
    return null;
}
~~~

더 큰 배열을 살펴보자. 원소가 두개인 배열도 정렬하기 쉽다.
첫번째 원소가 두번째 원소보다 작은지 살펴본다. 만약 그렇지 않다면, 두 원소를 교환한다.
* 원소가 2개인 배열 [1, 7]
~~~
public int[] quickSort(int[] arr) {
    if(arr.length() < 2) return arr; // 기본 단계

    // 배열의 원소가 2개일 때
    if(arr.length() == 2) {
        int temp = 0;
        int first = arr[0]];
        int second = arr[1]];

        if(first > second) {
            temp = second;
            second = first;
            first = second;
        }
        return arr;
    }

    return null;
}
~~~

원소가 세개인 배열은 어떨까? 
* 원소가 세개인 배열 [33, 15, 10]

배열을 기본 단계로 나눠야 한다.
배열의 첫번째 원소를 기준 원소라고 해보자.
* 기준 원소 33

이제 모든 원소를 기준 원소보다 작은 원소와 큰 원소로 분류한다.
이것을 `분할`이라고 한다.
* 33보다 작은 수의 배열 [15, 10]
* 33보다 큰 수의 배열 []

두개의 하위 배열은 정렬되어 있지 않다. 
하위의 배열들이 정렬되어 있으면 `왼쪽 배열(33보다 작은 수 배열) + 기준원소 + 오른쪽 배열(33보다 큰 수 배열)`과 같이 배열들을 합칠 수 있다.
그러면 [10, 15] + 33 + [] = [10, 15, 33]으로 정렬된 배열이 된다.
이를 어떻게 정렬해야 할까?

퀵정렬의 기본 단계에서 원소의 개수가 두개인 배열이나 원소가 없는 빈 배열을 정렬하는 방법을 이미 알고 있다. (기본 단계)
그러므로 이 두 개의 하위 배열에 대해서도 퀵 정렬을 호출하고 결과를 합치면 전체 배열이 정립된다.
~~~
quicksort([15, 10]) + [33] + quicksort([])
~~~
OUTPUT : [10, 15, 33]

이 방법은 기준 원소가 어떤 것이라도 동작한다.
정리하자면 원소가 세개인 배열을 정렬하는 방법은 다음과 같다.
1. 기준 원소를 고른다
2. 배열을 기준 원소보다 작은 원소의 배열과 큰 원소의 배열, 이렇게 두 개의 하위 배열로 분류한다.
3. 하위 배열에 대해 재귀적으로 퀵 정렬을 실행한다.

만약 배열의 원소의 개수가 4개이면 어떨까?
* 원소가 네개인 배열 [33, 10, 15, 7]

33을 기준 원소로 골랐다고 가정하자.
* 왼쪽 배열(33보다 작은 수의 배열) [10, 15, 7]
* 오른쪽 배열(33보다 큰 수의 배열) []

왼쪽 배열은 3개이다.
이미 3개인 배열을 정렬하는 방법을 알고 있으므로 재귀적으로 호출한다.
이렇게 원소의 개수가 4개인 배열도 정렬할 수 있다. (5개, 6개...)
