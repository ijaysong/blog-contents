# 이진 탐색 (Binary Search)
정렬된 리스트를 절반으로 나누어 타겟 값을 찾는 알고리즘을 말한다.

예를 들어 1~100 사이의 숫자 가운데서 57을 찾아낸다고 해보자.  
가능한 적은 횟수의 추측으로 해당 숫자를 찾아내야 한다.

만약 1,2,3,4 … 순서대로 모두 추측한다면 57에 도달할때 까지 숫자를 세어야 할 것이다. (57회)  
이와 같은 방법을 `단순 탐색 (Simple Search)`라고 한다. 


하지만 이진 탐색 알고리즘을 사용한다면 7회만에 해당 숫자를 찾을 수 있다.  
* 1~100의 중간값   : 50 -> 57보다 작다.  
* 51~100의 중간값  : 75 -> 57보다 크다.  
* 51~75의 중간값   : 63 -> 57보다 크다.  
* 51~63의 중간값   : 58 -> 57보다 크다.  
* 51~57의 중간값   : 54 -> 57보다 작다.  
* 55~57의 중간값   : 56 -> 57보다 작다.  
* 57 -> 정답!!

길이가 100인 리스트에서 타겟 값을 구하기 위해 단순 탐색은 57회, 이진 탐색은 4회 걸렸다.  
길이가 `10억`인 리스트에서 타겟값을 찾는다면 어떻게 될까??

|리스트 길이 | 단순 탐색 | 이진  탐색|
|---------------|-------------|-------------|
|100개        |100밀리 초|7밀리 초   |
|10,000개    |10초        |14밀리 초  |
|10억개        |11일        |32밀리 초  |

원소의 개수가 증가해도 이진탐색에 걸리는 시간은 얼마 늘어나지 않는다.  
하지만 단순 탐색의 시간은 엄청나게 증가한다.  
원소의 개수가 커질수록 이진 탐색은 단순 탐색보다 훨씬 빨라진다.

`빅오 표기법`은 알고리즘이 얼마나 빠른지 말해주는데 연산횟수를 비교하기 위한 것이다.  
예를 들어, 리스트의 크기가 n이라고 가정했을 때,   
단순 탐색은 원소를 하나씩 확인하니까 n번을 연산해야 하니까 빅오 표기법에 따른 실행시간은 O(n)이다.  
이진 탐색은 크기가 n인 리스트를 확인하기 위해 log n번의 연산이 필요하다. 빅오 표기법으로는 O(log n)이다.
* 단순 탐색 : O(n)  
* 이진탐색 : O(log n)

모든 상수 시간 알고리즘은 O(1)이라는 집합에 속한다.
어떤 알고리즘이 상수시간 임을 다르게 말하고 싶다면 그것이 O(1)에 있다고 말하면 된다.
모든 선형 알고리즘은 O(n)에 속하며, 모든 이차 알고리즘은 O(n제곱)에 속한다.
이렇게 알고리즘을 분류하는 표기법을 `빅오 표기법`이라고 한다.

이진탐색을 사용하면 실행시간을 절약할 수 있다는 장점이 있다.  
예를 들어, 특정 유저의 아이디와 패스워드가 일치하는지 확인하는 로그인 기능에서   
모든 유저의 정보를 확인하는 단순탐색보다, 아이디 순으로 정렬된 유저 정보 리스트를 가지고 이진 탐색을 한다면 훨씬 더 빠르게 수행할 수 있다.  
유저 정보가 더더더더 많아질수록 유용하다!!  

## 간단 정리 (Summary)
* 이진 탐색은 단순 탐색보다 아주 빠르다.
* O(log n)은 O(n)보다 빠르다. 리스트의 원소의 개수가 증가하면 상대적으로 더 빨라진다.
* 알고리즘의 속도는 시간으로 측정하지 않는다.
* 알고리즘의 시간은 어떻게 증가하는가로 측정한다.
* 알고리즘의 시간은 빅오 표기법으로 나타낸다.

## 이진 탐색 프로그램
정렬된 리스트가 있다. 해당 리스트에서 특정 숫자가 존재하는 인덱스 값을 반환하는 프로그램을 만들어보아라.  

~~~
import java.util.List;

public class Algo200604 {
	public static void main(String[] args) {
		List<Integer> sorted = List.of(1, 3, 5, 7, 9);
		System.out.println(getTargetIdx(sorted, 3));
	}
	
	public static int getTargetIdx(List<Integer> sorted, int target) {
		int start = 0; // 시작 인덱스
		int end = sorted.size() - 1; // 마지막 인덱스
		
		while(start <= end) {
			int mid = (start + end) / 2; // 중간 인덱스
			int guess = sorted.get(mid); // 중간값
			
			// 타겟보다 작다면
			if(guess < target) start = start + 1;
			// 타겟보다 크다면
			else if(guess > target) end = mid - 1;
			// 타겟과 일치한다면
			else return mid;
		}
		
		return 0;
	}
}
~~~

