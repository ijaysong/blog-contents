# `다익스트라 알고리즘`

## `너비 우선 탐색 vs 다익스트라 알고리즘`
최단 경로, 즉 가장 짧은 길을 찾기 위해 `너비 우선 탐색` 알고리즘을 사용했다.
가장 빠른 경로를 찾고 싶다면 어떻게 해야 할까?
`다익스트라 알고리즘`이라는 알고리즘을 사용하면 최단 시간 경로를 구할 수 있다.

## `다익스트라 알고리즘`
다익스트라 알고리즘은 4단계가 걸린다.

출발점 -6-> A -1-> 도착점  
  |      ㅅ        ㅅ  
  2     /          |  
  |    3           5  
  V  /             |  
  B ----------------   

1. 가장 `가격`이 `싼` 정점을 찾는다. 가장 가격이 싼 정점이란 도달하는 데 시간이 가장 적게 걸리는 정점을 마란다.
2. 이 정점의 이웃 정점들의 가격을 조사한다.
3. 그래프 상의 모든 정점에 대해 이러한 일을 반복한다.
4. 최종 경로를 계산한다.

### 1단계
가장 싼 정점을 찾는다.
|정점  | 정점까지 걸리는 시간                      |
|-----|--------------------------------------|
|A    | 6                                    |
|B    | 2                                    |
|도착점 | 무한대(얼마나 걸리는지 아직 알 수 없기 때문에) |

### `2단계`
가장 적게 걸리는 정점 B의 모든 이웃에 대해 정점 B를 통과하여 정점 A에 도달하는데 걸리는 시간을 계산한다.
|정점  | 정점까지 걸리는 시간                        |
|-----|----------------------------------------|
|A    | 6 -> 5 (정점 A에 도덜하는 더 빠른 경로를 찾음)  |
|B    | 2                                      |
|도착점 | 7                                      |

A에 도달하는 더 빠른 경로를 찾았다.
정점 A에 도달하는데 6분이 걸렸지만, 정점 B를 거치면 5분 밖에 걸리지 않는다.
정점 B의 이웃 정점에 대해 더 빠른 경로를 찾으면 가격을 바꾼다.
* 정점 A로 가는 더 짧은 거리 : 6 -> 5분
* 도착점까지 가는 더 짧은 거리 : 무한대 -> 7분

### 3단계
지금까지 한 일을 반복한다.

#### 다시 1단계
가장 빨리 도착할 수 있는 정점을 찾는다.
정점 B는 이미 처리했고, 정점 A가 그 다음으로 시간이 적게 걸린다.
|정점  | 정점까지 걸리는 시간 |
|-----|-----------------|
|A    | 5               |
|B    | 2               |
|도착점 | 7               |

#### 다시 2단계
정점 A의 이웃 정점에 대한 가격을 수정한다.
A를 통해 도작점까지의 거리가 6분으로 줄었다.
|정점  | 정점까지 걸리는 시간 |
|-----|-----------------|
|A    | 5               |
|B    | 2               |
|도착점 | 6               |

## 용어 설명
디익스트라 알고리즘을 사용할 때, 그래프의 각 간선은 어떤 숫자를 가진다.
이 숫자를 `가중치`라고 한다.
참고로, 가중치를 가지는 그래프는 `가중 그래프`라고 한다.
가중치가 없는 그래프는 `균일 그래프`라고 한다.

균일 그래프에서 최단 경로를 계산할 때는 너비 우선 탐색을 사용한다.
가중 그래프에서 최단 경로를 계산할 때는 다익스트라 알고리즘을 사용한다.

`사이클`은 그래프가 어떤 저점에서 출발하여 한 바퀴 돌아 같은 정점에서 끝난다는 뜻이다.
사실 무방향 그래프는 두 정점이 서로를 향하고 있는 것을 뜻한다. 즉, 사이클이다.
(참고 = 방향그래프 : 마이클 -> 레이첼)
다익스트라 알고리즘은 방향성 비순환 그래프(Directed Acyclic Graph), 줄여서 DAG라고 불리는 그래프에만 적용된다.

## 다익스트라 알고리즘을 사용한 물물교환
Hello Coding 알고리즘 166페이지 참조

각 정점에 대한 가격표이다.
|부모  |정점  | 가격  |
|-----|-----|------|
|악보  |LP   | 5    |
|악보  |포스터 | 0    |
| -   |기타  | 무한대 (아직 이 정점들에 도달하지 못해 알지 못한다)|
| -   |드럼  | 무한대 |
| -   |피아노 | 무한대 |

### 1단계
가격이 가장 싼 정점을 찾는다.
포스터가 0달러로 가장 싸다.

이 부분이 다익스트라 알고리즘의 핵심 아이디어이다.
`그래프에서 가장 가격이 싼 정점을 찾는다. 그 가격보다 더 싸게 그 정점에 도달하는 방법은 없다.`

### 2단계
그 이웃까지 도달하는데 걸리는 시간(가격)을 계산한다.
이제 베이스 기타와 드럼 세트 가격을 표에 적을 수 있다.
가격이 가장 싼 정점, 포스터를 지나온 가격이므로 포스터가 부모 정점이 된다.

|부모  |정점  | 가격  |
|-----|-----|------|
|악보  |LP   | 5    |
|악보  |포스터 | 0    |
|LP   |기타  | 30   |
|LP   |드럼  | 35   |
| -   |피아노 | 무한대 |

#### 다시 1단계
LP가 5달러로 두번째로 싼 정점이다.

#### 다시 2단계
모든 이웃 정점의 가격을 갱신한다.
드럼과 기타의 가격이 바뀌었다.
LP로부터 출할해서 드럼과 기타에 도달하는 것이 더 싸다는 뜻이다.
이제 LP가 두 악기의 새로운 부모 정점이 된다.

|부모  |정점  | 가격  |
|-----|-----|------|
|악보  |LP   | 5    |
|악보  |포스터 | 0    |
|LP   |기타  | 20   |
|LP   |드럼  | 25   |
| -   |피아노 | 무한대 |

#### 다시 1단계
기타가 20달러로 세번째로 싼 정점이다.

#### 다시 2단계
그 이웃 정점의 가격을 갱신한다.
피아노의 가격을 알게 되었다.
|부모  |정점  | 가격  |
|-----|-----|------|
|악보  |LP   | 5    |
|악보  |포스터 | 0    |
|LP   |기타  | 20   |
|LP   |드럼  | 25   |
|기타  |피아노 | 40   |

#### 다시 1단계
드럼이 25달러로 네번째로 싼 정점이다.

#### 다시 2단계
그 이웃 정점의 가격을 갱신한다.
피아노의 가격이 바뀌었다.
드럼 세트를 매매하면 피아노를 더 싸게 구할 수 있다는 뜻이다.
즉, 라마가 가장 싸게 피아노를 구하는 가격은 35달러이다.
|부모  |정점  | 가격  |
|-----|-----|------|
|악보  |LP   | 5    |
|악보  |포스터 | 0    |
|LP   |기타  | 20   |
|LP   |드럼  | 25   |
|드럼  |피아노 | 35   |

정점을 거꾸로 따라가 부모 정점을 찾아가면 완전한 경로를 찾을 수 있다.
: 악보 -> LP -> 드럼 -> 피아노

## 간선의 가중치가 음수인 경우
사실 음의 가중치가 있으면 다익스트라 알고리즘을 사용할 수 없다.
다음의 예제를 보자.

악보 -5-> LP
|      /
0   -7
|  </
포스터 -35-> 드럼

1. 우선 가격표를 만든다.
|정점 | 가격  |
|----|------|
|LP  | 5    |
|포스터| 0    |
|드럼 | 무한대 |

2. 가장 싼 정점을 찾아서 이웃의 가격을 갱신한다.
이 경우에는 포스터가 가장 싼 정점이니까 다익스트라 알고리즘에 따라 0보다 싼 경로는 없다.
(물론 이 경우에는 틀렸다. LP -> 포스터의 경로가 가장 쌈)
어쨌든 이웃 정점의 가격을 갱신한다.
|정점 | 가격  |
|----|------|
|LP  | 5    |
|포스터| 0    |
|드럼 | 35   |

드럼의 가격은 35달러이다.

3. 아직 처리하지 않는 두번째로 싼 정점을 찾는다. (LP)
4. 이웃 정점의 가격을 갱신한다.
|정점 | 가격  |
|----|------|
|LP  | 5    |
|포스터| -2   |
|드럼 | 35   |

포스터의 가격이 갱신되었다. (0 -> -2)
이미 포스터 정점을 처리했는데 그 가격이 바뀌어 큰 문제가 발생했다.
`어떤 정점을 처리하면, 그 정점에 도달하는 더 싼 경로는 존재하지 않아야 하는데, 포스터에 도달하는 더 저렴한 길이 발견된 것이다.`
드럼에는 이웃이 없으니까 여기서 알고리즘은 종료된다.
최종가격은 다음과 같다.

|정점 | 가격  |
|----|------|
|LP  | 5    |
|포스터| -2   |
|드럼 | 35   |

33달러밖에 들지 않는 경로가 있다는 것을 알지만, 다익스트라 알고리즘은 그 경로를 찾지 못했다.
다익스트라 알고리즘에서는 포스터 정점을 이미 처리했기 때문에 그 정점에 도달하는 더 싼 경로는 없다고 가정해버린다.
그래서 음의 가중치를 가진 간선이 있으면 다익스트라 알고리즘을 사용할 수 없다.
만약 음의 가중치를 가진 그래프에서 최단 경로를 찾고 싶으면 벨만-포드 알고리즘을 사용하면 된다.

## 구현
다익스트라 알고리즘을 코드로 어떻게 구현하는지 살펴보자.
예제로 사용할 그래프는 다음과 같다.

출발점 -6-> A
 |      ㅅ |
 2     /  1
 |    3   |
 ㄴ  /     ㄴ
 B -5-> 도착점

해당 예제를 코딩하려면 3개의 해쉬 테이블이 필요하다

<그래프>
|정점   | 이웃정점 | 가격   |
|------|--------|-------|
| 출발점 | A      | 6    |
|      | B      | 2    |
| A    | 도착점   | 1    |
| B    | A      | 3    |
|      | 도착점   | 5    |
| 도착점 | -      | -    |

<가격>
|정점   | 가격   |
|------|-------|
| A    | 6     |
| B    | 2     |
| 도착점 | 무한대 |

<부모>
|정점   | 부모   |
|------|-------|
| A    | 출발점 |
| B    | 출발점 |
| 도착점 | -    |

알고리즘을 실행하면서 가격, 부모 해시 테이블을 갱신하게 된다.
먼저 그래프 테이블 부터 구현해보자.
정점을 키로 하고, 값에는 이웃 정점과 함께 그 이웃의 가격도 저장해야 한다.
해시 테이블 내부에 다른 해시 테이블을 가지도록 구현한다.
~~~
public void dijkstra() {
    // 그래프 해쉬테이블 만들기
    Map<String, Map<String, Integer>> graph = new HashMap<>();
    Map<String, Integer> details = null;
    
    // 출발점
    details = new HashMap<>();
    details.put("A", 6);
    details.put("B", 2);
    graph.put("start", details);
    
    // 정점 A
    details = new HashMap<>();
    details.put("fin", 1);
    graph.put("A", details);
    
    // 정점 B
    details = new HashMap<>();
    details.put("A", 3);
    details.put("fin", 5);
    graph.put("B", details);
    
    // 도착점
    graph.put("fin", null);
}
~~~

## `Summary`
* 너비 우선 탐색은 가중치가 없는 균일 그래프에서 최단 경로를 계산하는데 사용된다.
* 다익스트라 알고리즘은 가중 그래프에서 최단 거리를 계산하는데 사용된다.
* 다익스트라 알고리즘은 모든 가중치가 양수 일때만 정상적으로 동작한다.
* 만약 가중치가 음수이면, 벨만-포드 알고리즘을 사용한다.