# `너비 우선 탐색`

너비 우선 탐색(BFS, Breath-First Search)를 사용하면 두 항목 같의 최단 경로를 찾을 수 있다.
최단 경로, 즉 가장 짧은 것을 찾는데 유용하다는 것이다.
친구 집까지 가는 최단 경로 일 수도 있고, 체스 게임에서 체크 메이트를 만드는데 필요한 최소한의 수 일 수도 있다.
이렇게 최단 경로 문제를 푸는 알고리즘을 너비 우선 탐색이라고 한다.

## `그래프란 무엇인가`
그래프란 연결의 집합을 모형화 한것이다.
그래프는 `정점`과 `간선`으로 이루어져 있으며, 정점은 려거 개의 다른 정점과 바로 이어질 수 있다.
바로 이어진 정점을 `이웃`이라고 한다.

정점 --(간선)--> 정점 --(간선)--> 정점

그래프는 항목들이 서로 어떻게 연결되어 있는지를 모형화 하는 방법이다.

## `너비 우선 탐색이란 무엇인가`
너비 우선 탐색은 그래프를 대상으로 하는 다른 종류의 탐색 알고리즘이다.
(이외에도 이진탐색이라는 탐색 알고리즘이 있다.)
너비 우선 탐색은 다음과 같은 두 가지 종류의 질문에 대답하는데 도움이 된다.
* 질문 유형 1 : 정점 A에서 정점 B로 가는 경로가 존재하는가?
* 질문 유형 2 : 정점 A에서 정점 B로 가는 최단 경로는 무엇인가?

### `최단경로 찾기`
기준이 되는 정점에서 가장 가까운 위치에 있는 정점을 찾아 나가므로 단순히 A에서 B로 가는 경로를 찾는 것이 아니라 최단 경로를 찾을 수 있다.
가장 가까운 순서대로 목록에 더해, 더해진 순서대로 탐색해야 한다.
큐라는 자료구조를 사용한다.

### `큐`
큐는 맛집에 들어가기 위해서 줄을 서 있는 것과 같다.
맨 앞에 서있다면, 제일 먼저 식당에 들어가게 된다.
큐도 마찬가지이다.
큐는 큐 안의 원소에 임의로 접근할 수 없다는 점에서 스택과 비슷하다.
큐는 `삽입`과 `제거`라고 하는 두가지 연산이 있다.
큐를 사용하면 목록에 먼저 추가된 것을 꺼내어 탐색하게 한다.
그래서 큐를 선입 선출(FIFO, First In First Out) 자료구조라고 한다.
반대로 스택은 후입 선출(LIFO, Last In First Out) 자료구조이다.

## `그래프의 구현`
그래프는 몇 개의 정점으로 이루어져 있다.
각각의 정점은 이웃하는 정점과 연결되는데, 이러한 관계를 표시하는 자료구조가 해쉬 테이블이다.
해쉬 테이블을 사용하면 키에 값을 할당하여 특정 정점에 이웃하는 정점을 할당할 수 있다.

정점 A에 인접한 이웃 : 정점 B, C, D
{"A", {"B", "C", "D"}}

정점에서 특정 정점을 향한 방향을 가지는 그래프를 `방향 그래프` 라고 한다.
관계에는 방향성이 있다.

A -> B
해당 관계에는 방향성이 있다.
B는 A의 이웃이지만, A는 B의 이웃이 아니다.

A - B
해당 관계에는 방향성이 없다.
무방향 그래프로 방향성을 가지고 있지 않기 때문에, 두 정점은 서로 이웃이 된다.
A는 B의 이웃이다.
B도 A의 이웃이다.

## `알고리즘의 구현`
예를 들어, 내가 망고 농장의 주인이라고 생각해보자.
망고를 팔아줄 수 있는 판매상을 찾고 있는데, 페이스북 친구 목록 가운데 망고 판매상이 있는지 확인하고 싶다.
만약에 친구들 중에 망고 판매상이 없다면, 친구의 친구를 통해서라도 찾고 싶다.
목표는 나의 네트워크에서 망고 판매상을 찾는 것이다. (전체 네트워크를 탐색 -> 너비 우선 탐색)

위와 같은 케이스를 해결하는 알고리즘은 다음과 같다.
1. 확인할 사람의 명단을 넣을 큐를 준비한다.
2. 큐에서 한 사람을 꺼낸다.
3. 이 사람이 망고 판매상인지 확인한다.
   1. 망고 판매상이라면? 종료
   2. 망고 판매상이 아니라면? 그 사람의 이웃을 모두 큐에 추가한다.
4. 2~3번의 과정을 반복한다.
   1. 만약 큐가 비어있으면 네트워크에는 망고 판매상이 없다.

위 알고리즘의 수도코드
~~~
public boolean algo() {
    // 새 큐를 생성
    Queue<String> queue = new LinkedList();
    // 내 친구 목록을 큐에 등록
    String[] yourList = getFriendList("you");
    for(String yourfriend : yourList) queue.add(yourfriend);
    
    // 큐가 비어 있지 않는 한 계속 실행
    while(!queue.isEmpty()) {
        // 큐의 첫번째 사람을 꺼냄
        String person = queue.poll();
        // 망고 판매상인지 확인
        if(person.isSeller()) {
            System.out.println(person + "은 망고 판매상이 맞음!");
            return true;
        } else {
            // 망고 판매상이 아님. 모든 이웃을 탐색 목록에 추가
            String[] friendList = getFriendList(person);
            for(String friend : friendList) queue.add(friend);
        }
    }
    // 여기에 도달했다는 것은 망고 판매상이 아무도 없다는 의미
    return false;
}
~~~

## `Summary`
* 너비 우선 탐색은 A에서 B로 가는 경로가 있는지 알려준다.
* 만약 경로가 존재한다면 최단 경로도 찾아준다.
* 만약 x까지의 최단 경로를 찾는 문제가 있다면 그 문제를 그래프로 모형화하여 너비 우선 탐색으로 문제를 풀 수 있다.
* 방향 그래프는 화살표를 가지며, 화살표 방향으로 관계를 가진다. (A -> B : A가 B에게 돈을 빚지고 있다는 뜻이다.)
* 무방향 그래프는 화살표가 없고, 둘 간의 상호 관계를 나타낸다. (A - B : A와 B가 데이트를 했다는 뜻이다.)
* 큐는 선입선출이고, 스택은 후입선출이다.
* 탐색 목록에 추가된 순서대로 사람을 확인해야 한다. 그래서 탐색 목록은 큐가 되어야 한다. 그렇지 않으면 최단 경로는 구할 수 없다.
* 누군가를 확인한 다음에는 두 번 다시 확인하지 않도록 한다. 그렇지 않으면 무한 반복이 되어 버릴 수 있다.
