# 블룸필터와 하이퍼로그로그
구글 검색서비스를 운영하고 있어서 웹 페이지들을 크롤링 한다고 해보자.
이전에 찾아보지 않았던 웹 페이지만 크롤링 하기를 원한다.
그러려면 이 페이지가 전에 크롤링 했던 것인지 아닌지 알아야 한다.
어떻게 해야할까?

해쉬 테이블을 사용하면 이 작업을 빨리 수행할 수 있다.
대형 해쉬 테이블을 만들어서 크롤링할 웹 페이지의 주소를 키로 하여 구성할 수 있다.

| URL          | 크롤링 유무 |
|--------------|----------|
| facebook.com | YES      |
| adit.io      | YES      |

adit.io라는 웹 페이지가 이미 크롤링 된 것인지 확인하려고 해쉬 테이블을 보면,
adit.io라는 키가 해쉬 테이블에 있고, 값이 YES이므로 이미 크롤링 되었다는 것을 알 수 있다.
해쉬 테이블에 대한 평균 탐색 시간은 O(1)이므로 상수 시간으로 확인할 수 있다.
* adit.io -> YES

딱 한 가지, 해쉬 테이블이 엄청 크다는 것이다.
구글은 수조 개의 웹 페이지를 인덱싱하는데, 이렇게 인덱싱한 모든 주소를 해쉬 테이블에 가지고 있다면 어마어마한 저장 공간이 필요할 것이다.
이렇데 데이터가 너무 많은면 더 참신한 방법이 필요하다.

## 블룸 필터
블룸필터가 이 문제에 대한 해답이다.
블룸 필터는 확률론적인 자료 구조이다. (거의 대부분 옳은 답을 주지만, 항상 그렇지는 않다.)

* 블품필터는 틀린 답을 맞다고 할 수도 있다. ex) '이미 크롤링한 사이트입니다'라는 답을 얻었더라도 사실 크롤링 하지 않았던 사이트 일 수도 있다.
* 하지만 맞는 답으 틀리다고 하진 않는다. 즉, '크롤링 하지 않은 사이트 입니다'라는 답이 나왔다면 진짜 크롤링 한 적이 없다는 뜻이다.

블룸필터는 저장 공간을 아주 적게 차지하기 때문에 획기적이다.
해쉬 테이블이라면 모든 웹 주소를 저장해야 하지만 블품 필터는 그렇게 하지 않는다.
항상 정답이 필요한 상황이 아니라면 블룸 필터가 아주 유용하다. 
ex) 사용자가 악성 코드가 있는 웹 사이트로 가지 않도록 악성 웹 사이트 주소를 저장해놓고, 새로운 URL 요청이 왔을 때 이 사이트가 악성 사이트 목록에 있는지 확인할 때
'이 사이트는 악성 코드가 있을 수도 있습니다. 주의하세요'

## 하이퍼로그로그
블품필터와 비슷한 알고리즘으로 하이퍼로그로그라는 것이 있다. 
비슷하게 확률론적 방법 중 하나이다.
만약 구글에서 사용자 검색내역 중 특정한 검색에 대한 홧수를 세고 싶다거나,
아마존에서 오늘 사용자가 특정 상품을 몇 번 봤는지 알고 싶다고 해보자.

구글이라면 모든 검색에 대해 로그를 남겨야 할 것이다.
사용자가 무언가를 검색할 때마다 그 항목이 있는지 확인한 후에 만약 없다면 로그에 추가해야 한다.
이를 위해 많은 저장공간이 필요하다.

하이퍼로그로그는 집합에 있는 똑같은 원소의 개수를 대략적으로 셀 수 있다.
정확한 답을 주진 않지만, 정확한 값을 주기 위해 필요한 메모리의 아주 일부분만 사용해서 꽤 근사한 값을 줄 수 있다.
