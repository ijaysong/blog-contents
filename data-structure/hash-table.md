# `해쉬테이블`

## `해쉬 함수`
해쉬함수는 문자열을 받아서 숫자로 반환(할당)하는 함수이다.
ex) NAMASTE -> [해쉬 함수] -> 7  
    HOLA    -> [해쉬 함수] -> 4  
    HELLO   -> [해쉬 함수] -> 2

문자열을 넣었을 때 나오는 숫자들에 특정한 패턴이 보이지 않는 것 같지만, 사실 해쉬 함수는 다음과 같은 요건을 갖추어야 한다.
* 일관성 : "apple"을 넣었을 때 "4"를 반환한다면, "apple"을 넣을 때 마다 반환되는 값이 같아야 한다. 그렇지 않으면 해쉬 함수로서의 역할을 할 수 없다.
* 다른 단어가 들어가면 다른 숫자가 나와야 한다. 어떤 단어를 넣어도 "1"만 나온다면 좋은 해쉬 함수가 아니다. 서로 다른 단어에 대해 모두 서로 다른 단어가 나와야 한다.

가게에서 판매하는 상품의 가격을 저장하는 장부를 만든다고 생각해보자.

리스트나 배열에서 상품의 가격을 찾기 위해서 일일히 찾거나 (단순탐색 : O(n)),
혹은 정렬된 리스트나 배열에서 이진탐색을 사용해 찾을 수도 있다.(이진탐색 : O(log n))
하지만 해쉬 함수를 사용하면 어떤 방법보다도 빠르게 가격을 찾을 수 있다.(해쉬 : O(1))

1. 빈 배열이 있다. 해당 배열에 가격을 저장한다고 해보자.  
   [  ]
2. "우유"의 가격을 추가해보자. 해쉬함수는 3을 출력한다.
  우유 -> [해쉬함수] -> 3
3. "우유"의 가격은 인덱스 3에 저장한다.
   [ , , , 3400]
4. "다진마늘"의 가격도 추가해보자. 해쉬함수는 0을 반환한다.
   다진마늘 -> [해쉬함수] -> 0
5. "다진마늘"의 가격은 인덱스 0에 저장한다.
   [5000, , , 3400] 

이런 식으로 계속하면 전체 배열이 가격으로 채워질 것이다.
예를 들어 "우유"의 가격을 찾고자 한다면 해쉬함수는 3을 반환할 테니 인덱스 3의 값을 꺼내기만 하면 되는 것이다. 
해쉬함수는 가격이 저장된 정확한 위치를 알려준다. O(1)

## `해쉬 테이블을 사용하는 예`
### `해쉬 테이블로 조회하기`
예를 들어 특정 웹 사이트를 보고 싶다고 하자. (http://www.google.com)
그러면 컴퓨터는 구글 URL을 ip주소로 번역한다.
http://www.google.com -> 173.255.248.55

어떤 웹 사이트에 접속하든 그 주소는 모두 IP주소로 번역되어야 한다.
http://www.facebook.com -> 173.252.120.6

이런 과정을 DNS 확인 작업이라고 하며, 해시 테이블은 이 기능을 제공하는 방법 중 하나이다.

### `중복된 항목을 방지하기`
투표소를 관리하고 있다고 해보자.
누군가가 투표소로 오면, 중복 투표를 방지하기 위해 이미 투표한 사람의 목록에 이름이 있는지 확인한다.
이름이 있다면, 이미 투표한 것이므로 돌려보내고,
이름이 없다면, 리스트에 이름을 추가하고 투표할 수 있도록 안내한다.
~~~
public void checkVote(String name) {
    // voted는 Map<String,Boolean> 타입으로 이미 투표한 사람의 목록을 담고 있다.
    if(voted.contains(name)) {
        System.out.println("쫓아내세요!");
    } else {
        voted.put(name, true);
        System.out.println("투표장으로 안내해주세요");
    }
}
~~~

만약, 투표한 사람의 이름을 배열이나 리스트에 저장한다면 리스트 전체에 대해 단순탐색을 반복해야 하기 때문에 함수가 매우 느려질 것이라는 것을 생각해야 한다.

### `해쉬 테이블을 캐시로 사용하기`
웹 사이트를 개발하다보면 `캐싱`에 대한 이야기를 듣게 된다.
캐싱의 핵심 개념은 다음과 같다.
만약, facebook.com 웹 사이트에 방문한다고 가정해보자.
1. 페이스북 서버에 요청한다.
2. 서버는 잠시 생각한 다음 요청한 웹 페이지를 찾아서 보내준다.
3. 유저는 웹 페이지를 받는다.

예를 들어 페이스북 서버가 유저의 친구 활용 내역을 보여준다고 해보자.
그 모든 활동내역을 모아서 보여주는데 몇 초의 시간이 걸린다.
이 몇 초가 유저에게는 긴 시간으로 느껴질 수 있다.
페이스북 서버는 수백만의 사용자를 서비스 하고 있기 때문에, 그 몇 초가 수백만 배로 늘어날 수 있다.
페이스 북 서버는 모든 페이지를 서비스 하기 위해 열심히 돌아가고 있는 것이다.
페이스북을 더 빠르게 하면서 동시에 서버가 덜 일하도록 할 수있게 하는 것이 `캐싱`이다.

예를 들어 조카가 "이모! 달은 지구에서 얼마나 떨어져 있어?"라고 물어볼때마다 구글에서 검색해서 대답하는데 몇분이 걸란다. 하지만 달이 384,000km 떨어져 있다는 것을 외우고 있으면 답을 알고 있으니까 구글에 찾지 않고도 대답할 수 있다. 이렇게 정보를 다시 계산하지 않고 저장했다가 알려주는 것이 캐싱이다.

페이스 북에 로그인 하면 서버는 계속 움직이며 나에게 맞는 페이지를 보여준다. 
하지만 로그인 하지 않으면 모든 사람이 똑같은 로그인 페이지를 본다.
그래서 서버는 로그인 페이지를 저장해두고 바로 보여주는 것이다. 이것이 캐싱이다.

캐싱은 두가지 장점을 가지고 있다.
* 웹 페이지를 빨리 보여준다는 점
* 서버가 일을 덜 할 수 있다는 점

캐싱은 작업속도를 올리는 일반적인 방법이다.
모든 대형 웹 사이트는 캐싱을 사용하며,  그 자료는 바로 해시 테이블에 저장된다.

페이스 북은 홈페이지만 캐싱하는 것이 아니라 회사 소개, 회사 연락처, 사용 약관 등 많은 것을 캐싱하고 있다.
그래서 페이지의 URL에 해당 페이지의 자료를 할당한다.

facebook.com/about -> 회사 소개 페이지 자료
facebook.com       -> 홈페이지 자료

페이스 북을 방문할 때마다 서버는 먼저 해시 테이블에 저장된 페이지가 있는지 확인한다.
캐시에 URL이 없을 때만 서버가 작업을 하며, 자료를 반환하기 전에는 캐시에 저장한다.
그러므로 다음번에 누군가가 해당 URL을 요청하면 서버에 작업을 시키는 대신에 캐싱한 자료를 꺼내서 보내줄 수 있다.

1. 페이스 북의 URL을 호출
2. 해시 테이블에 있는지 확인  
3-1. 예: 해시 테이블의 내용을 전송  
3-2. 아니요 : 서버가 무언가 작업을 함

~~~
public CacheExample {
    private Map<UrlVo, DataVo> cache = new HashMap<>();

    public DataVo getPage(UrlVo url) {
        if(cache.containsKey(url)) {
            return cache.get(url);
        } else {
            DataVo data = getDataFromServer(url);
            cache.put(url, data);
            return data;
        }
        return null;
    }
}
~~~

### 해쉬 테이블의 장점
* 어떤 것과 다른 것 사이의 관계를 모형화 할 수 있다.
* 중복을 막을 수 있다.
* 서버에게 작업을 시키지 않고 자료를 캐싱할 수 있다.

## `충돌`
해쉬함수는 첫글자에 따라 공간을 할당한다.
26개의 공간을 가진 배열이 있다고 해보자.
A로 시작하면 0번째 인덱스에, B로 시작하면 1번째 인덱스에...

Apple을 해시테이블에 넣으면 0번째 인덱스에 할당된다.
Banana는 1번째 인덱스에 할당된다.
Avocado를 해시테이블에 넣으면 어떻게 될까? 

이런 것을 `충돌`이라고 한다. 두개의 키가 같은 공간에 할당되는 것이다.
만약 그 공간에 Avocado를 넣게 되면 Apple을 덮어쓰게 되는 문제가 발생한다.
충돌을 해결하는 방법은 여러가지가 있다.

가장 간단한 방법은 같은 공간에 여러 개의 키를 연결 리스트로 만들어 넣는 것이다.
Apple과 Avocado가 같은 공간에 할당되었다.그 공간에서는 연결리스트가 시작된다.
Banana의 가격을 알고 싶다면 빨리 알고 싶다면 빨리 알 수 있지만, Apple의 가격을 알고 싶다면 시간이 더 걸린다. Apple을 찾을 때까지 연결리스트를 뒤져야 하기 떄문이다.

[0]:{Apple, 3500, 다음 인덱스의 위치} -> {Avocado, 3800, 다음 인덱스의 위치} -> {Almond, 2900, ...}
[1]:{Banana, 2100}
[2] ~ [26]

전체 해시 테이블이 두 공간만 빼놓고 모두 비어있고, 한 공간에는 거대한 연결 리스트가 있어, 결국 해쉬 테이블이 느려지게 된다.

여기서 얻은 교훈은 
* 방금은 모든 키를 한 공간에 할당했지만, 이상적으로는 키를 해쉬 테이블 전체에 고르게 할당해야 한다.
* 만약 연결리스트가 길어지면 해쉬 테이블의 속도도 느려진다.(하지만 좋은 해쉬 함수가 있다면 그런 일은 발생하지 않는다.


## `summary`
* 해쉬 테이블은 해쉬 함수와 배열을 결합해서 만든다.
* 충돌은 나쁘다. 충돌을 줄이는 해시 함수가 있어야 한다.
* 해쉬 테이블은 정말 빠른 탐색, 삽입, 삭제 속도를 가진다.
* 해쉬 테이블은 어떤 항목과 다른 항목의 관계를 모형화 하는데 좋다.
* 사용률이 0.7보다 커지면 해시 테이블을 리사이징할 때입니다.
* 해쉬 테이블은 (웹 서버 등에서) 데이터를 캐싱하는 데도 사용된다.
* 해쉬 테이블은 중복을 잡아내는 데도 뛰어나다.