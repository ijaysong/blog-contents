# `해쉬테이블`

## `해쉬 함수`
해쉬함수는 문자열을 받아서 숫자로 반환(할당)하는 함수이다.
ex) NAMASTE -> [해쉬 함수] -> 7  
    HOLA    -> [해쉬 함수] -> 4  
    HELLO   -> [해쉬 함수] -> 2

문자열을 넣었을 때 나오는 숫자들에 특정한 패턴이 보이지 않는 것 같지만, 사실 해쉬 함수는 다음과 같은 요건을 갖추어야 한다.
* 일관성 : "apple"을 넣었을 때 "4"를 반환한다면, "apple"을 넣을 때 마다 반환되는 값이 같아야 한다. 그렇지 않으면 해쉬 함수로서의 역할을 할 수 없다.
* 다른 단어가 들어가면 다른 숫자가 나와야 한다. 어떤 단어를 넣어도 "1"만 나온다면 좋은 해쉬 함수가 아니다. 서로 다른 단어에 대해 모두 서로 다른 단어가 나와야 한다.

가게에서 판매하는 상품의 가격을 저장하는 장부를 만든다고 생각해보자.

리스트나 배열에서 상품의 가격을 찾기 위해서 일일히 찾거나 (단순탐색 : O(n)),
혹은 정렬된 리스트나 배열에서 이진탐색을 사용해 찾을 수도 있다.(이진탐색 : O(log n))
하지만 해쉬 함수를 사용하면 어떤 방법보다도 빠르게 가격을 찾을 수 있다.(해쉬 : O(1))

1. 빈 배열이 있다. 해당 배열에 가격을 저장한다고 해보자.  
   [  ]
2. "우유"의 가격을 추가해보자. 해쉬함수는 3을 출력한다.
  우유 -> [해쉬함수] -> 3
3. "우유"의 가격은 인덱스 3에 저장한다.
   [ , , , 3400]
4. "다진마늘"의 가격도 추가해보자. 해쉬함수는 0을 반환한다.
   다진마늘 -> [해쉬함수] -> 0
5. "다진마늘"의 가격은 인덱스 0에 저장한다.
   [5000, , , 3400] 

이런 식으로 계속하면 전체 배열이 가격으로 채워질 것이다.
예를 들어 "우유"의 가격을 찾고자 한다면 해쉬함수는 3을 반환할 테니 인덱스 3의 값을 꺼내기만 하면 되는 것이다. 
해쉬함수는 가격이 저장된 정확한 위치를 알려준다. O(1)

## `해쉬 테이블을 사용하는 예`
### `해쉬 테이블로 조회하기`
예를 들어 특정 웹 사이트를 보고 싶다고 하자. (http://www.google.com)
그러면 컴퓨터는 구글 URL을 ip주소로 번역한다.
http://www.google.com -> 173.255.248.55

어떤 웹 사이트에 접속하든 그 주소는 모두 IP주소로 번역되어야 한다.
http://www.facebook.com -> 173.252.120.6

이런 과정을 DNS 확인 작업이라고 하며, 해시 테이블은 이 기능을 제공하는 방법 중 하나이다.

### `중복된 항목을 방지하기`
투표소를 관리하고 있다고 해보자.
누군가가 투표소로 오면, 중복 투표를 방지하기 위해 이미 투표한 사람의 목록에 이름이 있는지 확인한다.
이름이 있다면, 이미 투표한 것이므로 돌려보내고,
이름이 없다면, 리스트에 이름을 추가하고 투표할 수 있도록 안내한다.
~~~
public void checkVote(String name) {
    // voted는 Map<String,Boolean> 타입으로 이미 투표한 사람의 목록을 담고 있다.
    if(voted.contains(name)) {
        System.out.println("쫓아내세요!");
    } else {
        voted.put(name, true);
        System.out.println("투표장으로 안내해주세요");
    }
}
~~~

만약, 투표한 사람의 이름을 배열이나 리스트에 저장한다면 리스트 전체에 대해 단순탐색을 반복해야 하기 때문에 함수가 매우 느려질 것이라는 것을 생각해야 한다.

### `해쉬 테이블을 캐시로 사용하기`
웹 사이트를 개발하다보면 `캐싱`에 대한 이야기를 듣게 된다.
캐싱의 핵심 개념은 다음과 같다.
만약, facebook.com 웹 사이트에 방문한다고 가정해보자.
1. 페이스북 서버에 요청한다.
2. 서버는 잠시 생각한 다음 요청한 웹 페이지를 찾아서 보내준다.
3. 유저는 웹 페이지를 받는다.

예를 들어 페이스북 서버가 유저의 친구 활용 내역을 보여준다고 해보자.
그 모든 활동내역을 모아서 보여주는데 몇 초의 시간이 걸린다.
이 몇 초가 유저에게는 긴 시간으로 느껴질 수 있다.
페이스북 서버는 수백만의 사용자를 서비스 하고 있기 때문에, 그 몇 초가 수백만 배로 늘어날 수 있다.
페이스 북 서버는 모든 페이지를 서비스 하기 위해 열심히 돌아가고 있는 것이다.
페이스북을 더 빠르게 하면서 동시에 서버가 덜 일하도록 할 수있게 하는 것이 `캐싱`이다.

예를 들어 조카가 "이모! 달은 지구에서 얼마나 떨어져 있어?"라고 물어볼때마다 구글에서 검색해서 대답하는데 몇분이 걸란다. 하지만 달이 384,000km 떨어져 있다는 것을 외우고 있으면 답을 알고 있으니까 구글에 찾지 않고도 대답할 수 있다. 이렇게 정보를 다시 계산하지 않고 저장했다가 알려주는 것이 캐싱이다.

페이스 북에 로그인 하면 서버는 계속 움직이며 나에게 맞는 페이지를 보여준다. 
하지만 로그인 하지 않으면 모든 사람이 똑같은 로그인 페이지를 본다.
그래서 서버는 로그인 페이지를 저장해두고 바로 보여주는 것이다. 이것이 캐싱이다.

캐싱은 두가지 장점을 가지고 있다.
* 웹 페이지를 빨리 보여준다는 점
* 서버가 일을 덜 할 수 있다는 점

캐싱은 작업속도를 올리는 일반적인 방법이다.
모든 대형 웹 사이트는 캐싱을 사용하며,  그 자료는 바로 해시 테이블에 저장된다.

페이스 북은 홈페이지만 캐싱하는 것이 아니라 회사 소개, 회사 연락처, 사용 약관 등 많은 것을 캐싱하고 있다.
그래서 페이지의 URL에 해당 페이지의 자료를 할당한다.

facebook.com/about -> 회사 소개 페이지 자료
facebook.com       -> 홈페이지 자료

페이스 북을 방문할 때마다 서버는 먼저 해시 테이블에 저장된 페이지가 있는지 확인한다.
캐시에 URL이 없을 때만 서버가 작업을 하며, 자료를 반환하기 전에는 캐시에 저장한다.
그러므로 다음번에 누군가가 해당 URL을 요청하면 서버에 작업을 시키는 대신에 캐싱한 자료를 꺼내서 보내줄 수 있다.

1. 페이스 북의 URL을 호출
2. 해시 테이블에 있는지 확인  
3-1. 예: 해시 테이블의 내용을 전송  
3-2. 아니요 : 서버가 무언가 작업을 함

~~~
public CacheExample {
    private Map<UrlVo, DataVo> cache = new HashMap<>();

    public DataVo getPage(UrlVo url) {
        if(cache.containsKey(url)) {
            return cache.get(url);
        } else {
            DataVo data = getDataFromServer(url);
            cache.put(url, data);
            return data;
        }
        return null;
    }
}
~~~

### 해쉬 테이블의 장점
* 어떤 것과 다른 것 사이의 관계를 모형화 할 수 있다.
* 중복을 막을 수 있다.
* 서버에게 작업을 시키지 않고 자료를 캐싱할 수 있다.

## `충돌`
해쉬함수는 첫글자에 따라 공간을 할당한다.
26개의 공간을 가진 배열이 있다고 해보자.
A로 시작하면 0번째 인덱스에, B로 시작하면 1번째 인덱스에...

Apple을 해시테이블에 넣으면 0번째 인덱스에 할당된다.
Banana는 1번째 인덱스에 할당된다.
Avocado를 해시테이블에 넣으면 어떻게 될까? 

이런 것을 `충돌`이라고 한다. 두개의 키가 같은 공간에 할당되는 것이다.
만약 그 공간에 Avocado를 넣게 되면 Apple을 덮어쓰게 되는 문제가 발생한다.
충돌을 해결하는 방법은 여러가지가 있다.

가장 간단한 방법은 같은 공간에 여러 개의 키를 연결 리스트로 만들어 넣는 것이다.
Apple과 Avocado가 같은 공간에 할당되었다.그 공간에서는 연결리스트가 시작된다.
Banana의 가격을 알고 싶다면 빨리 알고 싶다면 빨리 알 수 있지만, Apple의 가격을 알고 싶다면 시간이 더 걸린다. Apple을 찾을 때까지 연결리스트를 뒤져야 하기 떄문이다.

[0]:{Apple, 3500, 다음 인덱스의 위치} -> {Avocado, 3800, 다음 인덱스의 위치} -> {Almond, 2900, ...}
[1]:{Banana, 2100}
[2] ~ [26]

전체 해시 테이블이 두 공간만 빼놓고 모두 비어있고, 한 공간에는 거대한 연결 리스트가 있어, 결국 해쉬 테이블이 느려지게 된다.

여기서 얻은 교훈은 
* 방금은 모든 키를 한 공간에 할당했지만, 이상적으로는 키를 해쉬 테이블 전체에 고르게 할당해야 한다.
* 만약 연결리스트가 길어지면 해쉬 테이블의 속도도 느려진다.(하지만 좋은 해쉬 함수가 있다면 그런 일은 발생하지 않는다.

## `성능`
평균적인 경우 해쉬 테이블은 모든 항목에 대해 O(1)의 시간이 걸린다.
O(1)은 상수 시간이라고 불린다. 상수 시간은 순간적이라는 뜻이 아니라, 해쉬 테이블의 크기에 상관없이 항상 똑같은 시간이 걸린다는 의미이다.
최악의 상황, 충돌이 발생하지 않으면 해쉬테이블은 자료 탐색, 삽입, 삭제에 대해서 좋은 성능을 가진다.
충돌을 피하려면 다음과 같은 것이 필요하다.
* 낮은 사용률
* 좋은 해시 함수

### `사용률`
해시 테이블의 사용률은 다음과 같이 계산 한다.
* 해시 테이블에 있는 항목의 수 / 해시 테이블에 있는 공간의 수

해쉬 테이블의 사용률이 1보다 크다는 것은 배열에 공간의 수보다 항목의 수가 더 많다는 뜻이다.
사용률이 커지기 시작하면, 해시 테이블의 공간을 추가해야 한다. 이를 `리사이징` 이라고 한다.
사용률이 낮을 수록 충돌이 적게 일어나고, 해시 테이블의 성능도 좋아진다.
보통은 사용률이 0.7보다 커지면 리사이징 한다.

### `좋은 해쉬 함수란`
좋은 해쉬함수란 배열에 값을 고루 분포시키는 함수이다.
나쁜 해쉬 함수는 값들이 뭉쳐져 있어서 충돌이 자주 발생한다.
ex) 
[0]:{Apple, 3500, 다음 인덱스의 위치} -> {Avocado, 3800, 다음 인덱스의 위치} -> {Almond, 2900, ...}
[1]:{Banana, 2100}
[2] ~ [26]

## 역 인덱스
검색엔진이 어떻게 동작하는지 짧게 살펴보자.
짧은 내용이 담긴 세개의 웹 페이지가 있다.

* A : 여러분 안녕?
* B : 안녕, 제임스?
* C : 여러분, 우리가 해냈어요!

이 내용으로 해쉬 테이블을 만들어보자.
해쉬 테이블의 키는 단어이고, 값은 그 단어가 어떤 웹 페이지에 있는지 나타낸다.

| 키      | 값   |
|--------|------|
| 안녕    | A, B |
| 여러분   | A, C |
| 제임스   | B    |
| 우리가   | C    |
| 해냈어요 | C    |

'안녕'이라는 단어를 검색한다고 하자.

| 키      | 값   |
|--------|------|
| 안녕    | A, B |

A와 B라는 웹 페이지에 그 단어가 존재하므로 이 결과를 사용자에게 보여주면 된다.
'여러분'이라는 단어를 검색한다고 하면 이번에는 웹페이지 A와 C를 보여주면 된다.

이런 자료구조를 `역 인덱스`라고 한다.
주로 검색엔진을 만드는데 사용된다.

## SHA 알고리즘 (보안 해쉬 알고리즘)
SHA 함수는 문자열을 받아 그 문자열에 대한 해쉬값을 반환한다.
ex) hello => 2cf24db...

SHA는 해쉬 함수이지만, 출력된 해쉬값은 숫자가 아니라 짧은 문자열이다.
해쉬 테이블용 해쉬함수는 배열 인덱스, 즉 숫자를 출력하지만 SHA는 문자열을 받아서 문자열을 출력한다.
SHA는 각기 다른 문자열에 대해 다른 해쉬값을 출력한다.
ex) hello => 2cf24db...
ex) algorithm => b1eb2ec...
ex) password => 5e88489...

### 파일비교
두 파일이 같은지 알아보는 데도 SHA를 사용할 수 있다.
특히 파일 크기가 클때 유용하다.
예를 들어, 4GB 크기의 파일이 있는데 친구가 가진 파일과 같은 파일인지 확인하고 싶다.
이때 이를 확인하기 위해 파일 전체를 이메일에 첨부해서 친구에게 보낼 필요는 없다.
대신에 두 파일에 대한 SHA 해쉬값을 비교하면 된다.

1. 내가 가진 파일의 SHA 해쉬값을 구한다. (해쉬값 : e2pakt...)
2. 친구가 가진 파일의 SHA 해쉬값을 구한다. (해쉬값 : e2pakt...)
3. 해쉬값이 같으면, 같은 파일!

### 패스워드 확인
SHA 알고리즘은 원래 문자열을 밝히지 않고 두 문자열을 비교할 때도 유용하다.
예를 들어, Gmail의 서비스가 해킹을 당해서 해커가 패스워드를 알아낼 수 있을까?
아니다. 구글은 패스워드 자체를 저장해놓지 않는다.
패스워드에 대한 SHA 해쉬값만 저장해놓는다.
유저가 패스워드를 이벽하면 구글에서는 그 문자열에 대한 해쉬값을 계산해서 데이터베이스에 저장해 놓았던 패스워드의 해쉬값과 비교한다.

1. 유저가 입력한 패스워드 : abc123
2. 유저가 입력한 패스워드의 해쉬값 : 6ca13d...
3. DB에 저장된 패스워드 해쉬값 : 6ca13d...
4. 해쉬값이 일치하면 패스워드도 일치한다고 판단한다.

SHA 알고리즘은 이렇게 패스워드를 해쉬하는데 자주 사용된다.
SHA 알고리즘은 단방향 해쉬이다.
문자열에서 해쉬값을 얻을 수는 있지만, 해쉬값에서 문자열을 알 수는 없다.
즉, 해커가 Gmail을 해킹해서 SHA 해쉬값을 본다고 하더라도 그 값을 변환해서 원래의 패스워드를 알수 없다.

abc123 -> 6ca13d...
   ?   <- 6ca13d...

SHA 알고리즘에도 SHA-0, SHA-1, SHA-2, SHA-3와 같은 여러가지가 있다.
현재, SHA-0과 SHA-1 알고리즘에 취약점이 있는 것으로 밝혀졌다.
만약 SHA 알고리즘을 사용한다면 SHA-2, SHA-3을 사용을 추천한다.
현재 패스워드 해쉬 함수의 표준은 bcrypt이지만, 어떤 것도 완벽하지 않다.

### 지역 민감 해싱
SHA 알고리즘은 지역 민감적이지 않다는 특징을 가지고 있다.
지역 민감적이란 말은 두 개의 입력 문자열이 비슷하면 출력되는 해쉬값도 비슷해진다는 뜻이다.

dog => cd6357
dot => e392da

이는 해커가 패스워드를 추측할 때 패스워드와 어느 정도 비슷해졌는지 알 수 없기 때문에 좋은 특성이다.

반대로 어떨 때는 지역 민감 해쉬 함수가 필요할 수도 있다.
이럴때는 Simhash를 사용한다.
Simhash를 쓰면 문자열이 조금 바뀌었을 때 해쉬값도 조금만 바뀐다.
이렇게 되면 두 개의 문자열이 어느 정도 비슷한지 알 수 있다.

* 구글은 Simhash를 사용해서 크롤링할 웹 페이지가 중복되었는지 판단한다.
* 교수는 Simhash를 사용해서 수강생이 레포트를 인터넷에서 베꼈는지 알 수 있다.
* Scribd 서비스는 사용자가 문서나 책을 업로드해서 다른 사람들과 공유하도록 한다. 하지만 저작권이 있는 내용은 업로드하지 못하도록 한다. 이 서비스는 Simhash를 사용해서 사용자가 업로드한 내용이 해리포터 책과 같은지 살펴보고, 만약 같은 내용이라면 자동으로 업로드를 거절하도록 한다.

Simhash는 위와 같은 상황에서 비슷한 항목을 찾아낼 때 유용하다.

## `summary`
* 해쉬 테이블은 해쉬 함수와 배열을 결합해서 만든다.
* 충돌은 나쁘다. 충돌을 줄이는 해시 함수가 있어야 한다.
* 해쉬 테이블은 정말 빠른 탐색, 삽입, 삭제 속도를 가진다.
* 해쉬 테이블은 어떤 항목과 다른 항목의 관계를 모형화 하는데 좋다.
* 사용률이 0.7보다 커지면 해시 테이블을 리사이징할 때입니다.
* 해쉬 테이블은 (웹 서버 등에서) 데이터를 캐싱하는 데도 사용된다.
* 해쉬 테이블은 중복을 잡아내는 데도 뛰어나다.