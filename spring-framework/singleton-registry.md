# 싱글톤 레지스트리
new 연산자를 사용하면 매번 다른 오브젝트가 출력됨을 당연히 알 수 있다.
~~~
DaoFactory factory = new DaoFactory();
UserDao dao1 = factory.userDao();
UserDao dao2 = factory.userDao();

System.out.println(dao1);
System.out.println(dao2);
~~~
출력 :
spring.book.dao.UserDao@118f375
spring.book.dao.UserDao@117a8bd


스프링의 애플리케이션 컨텍스트에 DaoFactory를 설정정보로 등록하고,
getBean()메소드를 이용해 userDao라는 이름으로 등록된 오브젝트를 가져와보면,
여러번 호출해도 동일한 오브젝트가 출력됨을 알 수 있다.
스프링은 여러 번에 걸쳐 빈을 요청하더라도 매번 동일한 오브젝트를 돌려준다는 것이다.
~~~
ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);

UserDao dao3 = context.getBean("userDao", UserDao.class);
UserDao dao4 = context.getBean(("userDao", UserDao.class);

System.out.println(dao3);
System.out.println(dao3);
~~~
출력 :
spring.book.dao.UserDao@ee22f7
spring.book.dao.UserDao@ee22f7

## 싱글톤 레지스트리로서의 애플리케이션 컨텍스트

### 싱글톤 패턴이란?
어떤 클래스를 애플리케이션 내에서 제한된 인스턴스 개수, 이름처럼 주로 하나만 존재하도록 강제하는 패턴이다.
이렇게 하나만 만들어지는 클래스의 오브젝트는 애플리케이션 내에서 전역적으로 접근이 가능하다.
단일 오브젝트만 존재해야 하고, 이를 애플리케이션의 여러 곳에서 공유하는 경우에 주로 사용한다.

### 서버 애플리케이션과 싱글톤
스프링은 별다른 설정을 하지 않으면 내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만든다.
왜 스프링은 싱글톤으로 빈을 만드는 것일까?

스프링이 주로 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 서버 환경이기 때문이다.
스프링이 처음 설계됐던 대규모의 엔터프라이즈 서버환경은 서버 하나당 최대로 초당 수십에서 수백번씩 브라우저나 여타 시스템으로부터의 요청을 받아 처리할 수 있는 높은 성능이 요구되는 환경이었다.
하나의 요청을 처리하기 위해 매번 클라이언트로부터 요청이 올때마다 오브젝트를 새로 만들어 사용한다면, 서버에 큰 부하가 걸리게 되기 때문에 사용자의 요청을 담당하는 여러 스레드에서 하나의 오브젝트를 공유해 동시에 사용하도록 한 것이다.

### 싱글톤 패턴의 구현
* 클래스 밖에서는 오브젝트를 생성하지 못하도록 private으로 만든다.
* 생성된 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 타입의 스태틱 필드를 정의한다.
* 스태틱 팩토리 메소드인 getInstance()를 만들고 이 메소드가 최도로 호출되는 시점에서 한번만 오브젝트가 만들어지게 한다. 생성된 오브젝트는 스태틱 필드에 저장된다. 또는 스태틱 필드의 초기값으로 오브젝트를 미리 만들어둘 수도 있다.
* 한번 오브젝트(싱글톤)가 만들어지고 난 후에는 getInstance() 메소드를 통해 이미 만들어져 스태틱 필드에 저장해둔 오브젝트를 넘겨준다.

~~~
public class UserDao {
    private static UserDao INSTANCE;

    private ConnectionMaker connectionMaker;

    private UserDao(ConnectionMaker connectionMaker) {
        this.connectionMaker = connectionMaker;
    }

    public static synchronized UserDao getInstance() {
        if (INSTANCE == null) INSTANCE = new UserDao(???);
        return INSTANCE;
    }
}
~~~

UserDao에 싱글톤을 위한 코드가 추가되었다.
private으로 바뀐 생성자는 외부에서 호출할 수 없기 때문에 DaoFactory에서 UserDao를 생성하여 Connectionmaker 오브젝트를 넣어주는게 이제는 불가능해졌다.

### 싱글톤 패턴의 한계
일반적으로 싱글톤 패턴 구현 방식에는 다음과 같은 문제가 있다.

* private 생성자를 갖고 있기 때문에 상속할 수 없다.
싱글톤 패턴은 생성자를 private으로 제한한다.
문제는 private 생성자를 가진 클래스는 다른 생성자가 없다면 상속이 불가능하다.
객체지향의 장점인 상속과 이를 적용한 다형성을 적용할 수 없다.
오브젝트의 경우 싱글톤으로 만들었을 때 객체 지향적인 설계의 장점을 적용하기가 어렵다는 점은 심각한 문제이다.

* 싱글톤은 테스트하기가 힘들다
싱글톤은 만들어지는 방식이 제한적이기 때문에 테스트에서 사용하기 힘들다.
싱글톤은 초기화 과정에서 생성자 등을 통해 사용할 오브젝트를ㄹ 다이내믹하게 주입하기도 힘들기 때문에 필요한 오브젝트는 직접 오브젝트를 만들어 사용할 수 밖에 없다.
이런 경우 테스트용 오브젝트로 대체하기 힘들다.

* 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.
서버에서 클래스 로더를 어떻게 구성하고 있는냐에 따라서 싱글톤 클래스임에도 하나 이상의 오브젝트가 만들어 질 수 있다.
여러 개의 JVM에 분산돼서 설치가 되는 경우에도 각각 독립적으로 오브젝트가 생기기 때문에 싱글톤으로서의 가치가 떨어진다.

* 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.
싱글톤은 사용하는 클라이언트가 정해져 있지 않다.
싱글톤의 스테틱 메소드를 이용해 언제든지 싱글톤에 쉽게 접근할 수 있기 때문에 에플리케이션 어디서든지 사용될 수 있고, 그러다보면 자연스럽게 전역 상태로 사용되기 쉽다.
아무 객체나 자유롭게 접근하고 수정하고 공유할 수 있는 전역 상태를 갖는 것은 객체지향 프로그래밍에서는 권장되지 않는 프로그래밍 모델이다.
그럴바에는 아예 스태틱 필드와 메소드로만 구성된 클래스를 사용하는 편이 낫다.


### 싱글톤 레지스트리
스프링은 서버환경에서 싱글톤이 만들어져서 서비스 오브젝트 방식으로 사용되는 것을 적극 지지한다.
하지만 자바의 기본적인 싱글톤 패턴의 구현 방식은 여러가지 단점이 있기 때문에 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다.
그것이 바로 `싱글톤 레지스트리`이다.

스프링 컨테이너는 싱글톤을 생성하고 관리하고, 공급하는 싱글톤 관리컨테이너이기도 하다.
싱글톤 레지스트리의 장점은 스태틱 메소드와 private 생성자를 사용해야 하는 비정상적인 클래스가 아니라 평범한 자바 클래스를 싱글톤으로 활용하게 해준다는 점이다.
평범한 자바 클래스라도 IoC 방식의 컨테이너를 사용해서 생성과 관계설정, 사용 등에 대한 제어권을 컨테이너에게 넘기면 손쉽게 싱글톤 방식으로 만들어져 관리되게 할 수 있다.
스프링의 싱글톤 레지스트리 덕분에 싱글톤 방식으로 사용될 애플리케이션 클래스라도 public 생성자를 가질 수 있다.

스프링은 IoC 컨테어일 뿐만 아니라, 고전적인 싱글톤 패턴을 대신해서 싱글톤을 만들고 관리해주는 싱글톤 레지스트리이다.
스프링이 빈을 싱글톤으로 만드는 것은 결국 오브젝트의 ㅅ애성 방법을 제어하는 IoC 컨테이너로서의 역할이다.

## 싱글톤과 오브젝트의 상태
싱글톤은 멀티스레드 환경이라면 여러 스레드가 동시에 접근해서 사용할 수 있다.
따라서 상태 관리에 주의를 기울여야 한다.
기본적으로 싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우에는 상태정보를 내부에 갖고 있지 않은 무상태 방식으로 만들어져야 한다.
다중 사용자의 요청을 한꺼번에 처리하는 스레드들이 동시에 싱글톤 오브젝트의 인스턴스 변수를 수정하는 것은 매우 위험하다.
저장할 공간이 하나뿐이니 서로 값을 덮어쓰고 자신이 저장하지 않은 값을 변경하고 유지하는 상태유지 방식으로 만들지 않는다.
(서버에 배포되고 여러 사용자가 동시에 접속하면 데이터가 엉망이 돼버리는 등 심각한 문제가 발생한다.)

무상태 방식으로 클래스를 만드는 경우, 각 요청에 대한 정보나, DB나 서버의 리소스로부터 생성한 정보는 어떻게 다뤄야 할까?
파라미터와 로컬변수, 리턴 값 등을 활용하면 된다.
메소드 파라미터나, 메소드 안에서 생성되는 로컬변수는 매번 새로운 값을 저장할 독립적인 공간이 만들어지기 때문에 싱글톤이라고 해도 여러 스레드가 변수의 값을 덮어쓸 일은 없다.

~~~
public class UserDao {
    // 초기에 설정하면 사용 중에는 바뀌지 않는 읽기전용 인스턴스 변수
    private ConnectionMaker connectionMaker; 

    // 매번 새로운 값으로 비뀌는 정보를 담은 인스턴스 변수. 심각한 문제가 발생한다.
    private Connection c;
    private User user;

    public User get(String id) throws ClassNotFoundException, SQLException {
		this.c = connectionMaker.makeConnection();
		
		PreparedStatement ps = c.prepareStatement(
				"SELECT * FROM USER WHERE id = ?");
		ps.setString(1, id);
		
		ResultSet rs = ps.executeQuery();
		rs.next();
		this.user = new User();
		this.user.setId(rs.getString("id"));
		this.user.setName(rs.getString("name"));
		this.user.setPassword(rs.getString("password"));
		
		rs.close();
		ps.close();
		c.close();
		
		return this.user;
	}
}
~~~

기존에 만들었던 UserDao와 다른 점은 기존에 로컬 변수로 선언하고 사용했던 Connection과 User를 클래스의 인스턴스 필드로 선언했다는 것이다.
따라서 싱글톤으로 만들어져서 멀티스레드 환경에서 사용하면 위에서 설명한대로 심각한 문제가 발생한다.
스프링의 싱글톤 빈으로 사용되는 클래스를 만들때는 기존의 UserDao처럼 개별적으로 바뀌는 정보는 로커련수로 정의하거나, 파라미터로 주고받으면서 사용하게 해야한다.

UserDao에서 인스턴스 변수로 정의해서 사용한 ConnectionMaker 인터페이스 타입의 connectionMaker는 읽기 전용의 정보이다.
읽기전용의 속성을 가진 정보라면 싱글톤에서 인스턴스 변수로 사용해도 좋다.

## 스프링 빈의 스코프
스프링이 관리하는 오브젝트인 빈이 생성되고, 존재하고, 적용되는 범위를 `빈의 스코프(scope)`라고 한다.
스프링 빈의 기본 스토프는 싱글톤이다.
싱글톤 스코프는 컨테이너 내에 한 개이ㅢ 오브젝트만 만들어져서, 강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안 계속 유지된다.
스프링에서 만들어지는 대부분의 빈은 싱글톤 스코프를 갖는다.

경우에 따라서 싱글톤 외의 스코프르 가질 수 있다.
대표적으로 프로토타입 스코프가 있다.
프로토타입은 싱글톤과 달리 컨테이너에 빈을 요청할 때마다 매번 새로운 오브젝트를 만들어준다.

그 외에도 웹을 통해 새로운 HTTP 요청이 생길때마다 생성되는 요청(request)스코프가 있고, 웹의 세셔놔 스코프가 유사한 세션(session)스코프도 있다.
